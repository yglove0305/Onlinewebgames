<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>돌림판 게임</title>
  <style>
    :root{
      --bg:#0f1220;
      --panel:#161a2f;
      --text:#e6e9f4;
      --muted:#a3aac2;
      --accent:#6ea8fe;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#f87171;
      --shadow: 0 8px 24px rgba(0,0,0,.25);
      --ring: 0 0 0 3px rgba(110,168,254,.35);
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font: 15px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      letter-spacing:.2px;
    }
    .app{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 18px;
      padding: 18px;
      min-height:100%;
      box-sizing: border-box;
    }
    @media (max-width: 980px){
      .app{grid-template-columns: 1fr}
    }
    .panel{
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 14px;
    }
    h1{font-size:20px;margin:0 0 6px}
    h2{font-size:16px;margin:16px 0 8px;color:var(--muted)}
    .row{display:flex; gap:8px; align-items:center}
    .row > *{flex:1}
    .input, select, button{
      background:#0b0e1b; color:var(--text);
      border:1px solid rgba(255,255,255,.08); border-radius:10px;
      padding:10px 12px; outline:none;
      transition: box-shadow .15s ease, border-color .15s ease, transform .06s ease;
    }
    .input:focus, select:focus{box-shadow: var(--ring); border-color: var(--accent)}
    .btn{
      background: linear-gradient(180deg, #2a6bf3, #2054c3);
      border:0; cursor:pointer; font-weight:600; letter-spacing:.2px
    }
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform: translateY(1px)}
    .btn.secondary{
      background: #0b0e1b; border:1px solid rgba(255,255,255,.12)
    }
    .btn.danger{background: linear-gradient(180deg, #ef4444, #c83535)}
    .tiny{font-size:12px;color:var(--muted)}
    .list{
      display:grid; gap:8px; margin-top:8px; max-height:280px; overflow:auto; padding-right:4px
    }
    .item{
      display:grid; grid-template-columns: 1fr 80px 90px auto;
      gap:8px; align-items:center; background:#0b0e1b; padding:8px; border-radius:10px;
      border:1px solid rgba(255,255,255,.06)
    }
    .color{
      width:100%; height:34px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:transparent; cursor:pointer
    }
    .wheel-wrap{
      position:relative; height:100%; min-height: 520px;
      display:grid; grid-template-rows: auto 1fr auto; gap:12px
    }
    .stage{
      position:relative; flex:1; display:flex; align-items:center; justify-content:center; min-height:420px;
      background: radial-gradient(1200px 600px at 50% 0%, rgba(255,255,255,.06), transparent 40%),
                  linear-gradient(180deg, rgba(255,255,255,.02), transparent 50%),
                  #0b0e1b;
      border:1px solid rgba(255,255,255,.06); border-radius:14px; box-shadow: var(--shadow)
    }
    canvas#wheel{width:100%; max-width:720px; height:auto; aspect-ratio:1/1; display:block}
    canvas#confetti{position:absolute; inset:0; width:100%; height:100%; pointer-events:none}
    .pointer{
      position:absolute; top:10px; left:50%; transform: translateX(-50%);
      width:0; height:0; border-left: 14px solid transparent; border-right:14px solid transparent;
      border-top: 24px solid var(--warn); filter: drop-shadow(0 3px 6px rgba(0,0,0,.5))
    }
    .hub{
      position:absolute; width:90px; height:90px; border-radius:50%;
      background:#0b0e1b; border:4px solid rgba(255,255,255,.08);
      display:grid; place-items:center; color:var(--muted); font-weight:700; letter-spacing:.5px;
      box-shadow: inset 0 0 24px rgba(0,0,0,.5), 0 6px 20px rgba(0,0,0,.35)
    }
    .controls{display:flex; gap:8px; flex-wrap:wrap}
    .pill{
      background:#0b0e1b; border:1px solid rgba(255,255,255,.1); padding:8px 10px; border-radius:999px;
      display:flex; align-items:center; gap:8px
    }
    .log{
      max-height:160px; overflow:auto; border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:10px; background:#0b0e1b
    }
    .log-item{display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px dashed rgba(255,255,255,.06)}
    .log-item:last-child{border-bottom:0}
    .switch{display:flex; align-items:center; gap:8px}
    .switch input{accent-color: var(--accent)}
    .right{display:flex; gap:8px; align-items:center}
    .badge{
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08); color:var(--muted)
    }
    .result{
      background:#0b0e1b; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px; display:flex; justify-content:space-between; align-items:center
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #0b0e1b; border:1px solid rgba(255,255,255,.12); padding:3px 6px; border-radius:6px; color: var(--muted)
    }
    .danger-outline{border-color: rgba(248,113,113,.4)}
    .ok{color:var(--good)}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>돌림판 설정</h1>
      <div class="tiny">라벨, 색상, 가중치를 자유롭게 조정하세요. 가중치가 높을수록 당첨 확률이 올라갑니다.</div>

      <h2>항목 관리</h2>
      <div class="row">
        <input id="label" class="input" placeholder="예: 점심 내기, 커피, 과자" />
        <input id="weight" class="input" type="number" min="1" step="1" value="1" />
      </div>
      <div class="row" style="margin-top:8px">
        <input id="color" class="color" type="color" value="#6ea8fe" />
        <button id="randColor" class="btn secondary" style="flex:0 0 auto">랜덤 색</button>
        <button id="add" class="btn">추가</button>
      </div>

      <div class="list" id="list"></div>

      <div class="row" style="margin-top:8px">
        <button id="reset" class="btn danger">전체 초기화</button>
        <button id="shuffle" class="btn secondary">색상 섞기</button>
        <button id="saveNow" class="btn secondary">지금 저장</button>
      </div>

      <h2>옵션</h2>
      <div class="row">
        <label class="pill"><span>회전 시간</span>
          <input id="duration" class="input" type="number" min="2" max="20" step="0.5" value="6" style="width:90px" />
          <span class="tiny">초</span>
        </label>
        <label class="pill"><span>최소 회전수</span>
          <input id="spinsMin" class="input" type="number" min="2" max="20" step="1" value="5" style="width:90px" />
        </label>
        <label class="pill"><span>최대 회전수</span>
          <input id="spinsMax" class="input" type="number" min="3" max="30" step="1" value="8" style="width:90px" />
        </label>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="switch"><input id="sound" type="checkbox" checked /> 틱 사운드</label>
        <label class="switch"><input id="confetti" type="checkbox" checked /> 컨페티</label>
        <label class="switch"><input id="dark" type="checkbox" checked /> 다크 모드</label>
      </div>

      <h2>기록</h2>
      <div class="log" id="log"></div>
    </div>

    <div class="panel wheel-wrap">
      <div class="right">
        <span class="badge">총 항목 <strong id="count">0</strong>개</span>
        <span class="badge">총 가중치 <strong id="totalW">0</strong></span>
        <span class="badge">단축키 <span class="kbd">Space</span> 스핀</span>
      </div>

      <div class="stage">
        <div class="pointer"></div>
        <canvas id="wheel"></canvas>
        <canvas id="confetti"></canvas>
        <div class="hub" id="hub">SPIN</div>
      </div>

      <div class="result">
        <div>
          <div class="tiny">결과</div>
          <div id="resultText" style="font-size:18px; font-weight:700">대기 중…</div>
        </div>
        <div class="controls">
          <button class="btn" id="spin">스핀</button>
          <button class="btn secondary" id="stop">즉시 멈추기</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  ;(()=>{
    // ---------- 상태 ----------
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);
    const canvas = $("#wheel");
    const ctx = canvas.getContext("2d");
    const confettiCanvas = document.querySelector("canvas#confetti");
    const cctx = confettiCanvas.getContext("2d");

    const state = {
      entries: [
        {label:"커피", color:"#6ea8fe", weight:1},
        {label:"간식", color:"#34d399", weight:1},
        {label:"점심 내기", color:"#fbbf24", weight:1},
        {label:"휴식", color:"#f472b6", weight:1},
      ],
      rotation: 0, // 현재 회전량 (라디안)
      spinning: false,
      anim: null,
      target: null, // {index, angle, rotationTarget, t0, dur}
      options: {
        duration: 6,
        spinsMin: 5,
        spinsMax: 8,
        sound: true,
        confetti: true,
        dark: true,
      },
      ticks: {lastIndex: -1},
      log: [],
    };

    // ---------- 저장 ----------
    const StorageKey = "wheel.entries.v1";
    const OptKey = "wheel.options.v1";
    const LogKey = "wheel.log.v1";

    function saveAll(){
      localStorage.setItem(StorageKey, JSON.stringify(state.entries));
      localStorage.setItem(OptKey, JSON.stringify(state.options));
      localStorage.setItem(LogKey, JSON.stringify(state.log));
      $("#saveNow").textContent = "저장됨";
      setTimeout(()=> $("#saveNow").textContent="지금 저장", 1000);
      renderBadges();
    }
    function loadAll(){
      try{
        const e = JSON.parse(localStorage.getItem(StorageKey));
        if(Array.isArray(e) && e.length){ state.entries = e }
      }catch{}
      try{
        const o = JSON.parse(localStorage.getItem(OptKey));
        if(o) Object.assign(state.options, o);
      }catch{}
      try{
        const l = JSON.parse(localStorage.getItem(LogKey));
        if(Array.isArray(l)) state.log = l;
      }catch{}
    }

    // ---------- 유틸 ----------
    const TAU = Math.PI*2;
    const deg = r => r * 180/Math.PI;
    const rad = d => d * Math.PI/180;
    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const lerp = (a,b,t)=> a+(b-a)*t;
    const easeOutCubic = t => 1 - Math.pow(1-t,3);
    const rand = (a,b)=> a + Math.random()*(b-a);
    const choiceWeighted = entries => {
      const total = entries.reduce((s,e)=> s + Math.max(0, +e.weight||0), 0);
      if(total<=0) return {index:-1};
      let r = Math.random()*total;
      for(let i=0;i<entries.length;i++){
        const w = Math.max(0, +entries[i].weight||0);
        if(r < w) return {index:i, total};
        r -= w;
      }
      return {index: entries.length-1, total};
    };
    const fitCanvas = (cv)=>{
      const dpr = Math.max(1, window.devicePixelRatio||1);
      const rect = cv.getBoundingClientRect();
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(rect.height * dpr);
      const ctx = cv.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0);
    };

    // ---------- 오디오 ----------
    let audioCtx = null;
    function tick(){
      if(!state.options.sound) return;
      if(!audioCtx) {
        try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
        catch{ return; }
      }
      const ctx = audioCtx;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "triangle";
      o.frequency.value = 1800;
      g.gain.value = 0.0001;
      o.connect(g).connect(ctx.destination);
      o.start();
      const now = ctx.currentTime;
      g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      o.stop(now + 0.09);
    }

    // ---------- 컨페티 ----------
    const confetti = {
      parts: [],
      spawn(n, color){
        const rect = confettiCanvas.getBoundingClientRect();
        for(let i=0;i<n;i++){
          confetti.parts.push({
            x: rect.width/2 + rand(-40,40),
            y: 20 + rand(-20,20),
            vx: rand(-2,2), vy: rand(1,3),
            rot: rand(0,TAU), vr: rand(-0.2,0.2),
            size: rand(6,12),
            color: color || `hsl(${Math.floor(Math.random()*360)} 90% 60%)`,
            life: rand(1.2,2.0)
          });
        }
      },
      update(dt){
        const g = 9.8 * 120; // px/s^2 scaled
        this.parts.forEach(p=>{
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += g * dt * 0.001;
          p.rot += p.vr * dt;
          p.life -= dt;
        });
        this.parts = this.parts.filter(p=> p.life>0 && p.y < confettiCanvas.height + 40);
      },
      draw(){
        cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
        this.parts.forEach(p=>{
          cctx.save();
          cctx.translate(p.x, p.y);
          cctx.rotate(p.rot);
          cctx.fillStyle = p.color;
          cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
          cctx.restore();
        });
      }
    };

    // ---------- 렌더 ----------
    function renderBadges(){
      $("#count").textContent = state.entries.length;
      const total = state.entries.reduce((s,e)=> s + Math.max(0, +e.weight||0), 0);
      $("#totalW").textContent = total;
    }
    function renderList(){
      const el = $("#list");
      el.innerHTML = "";
      state.entries.forEach((e, idx)=>{
        const row = document.createElement("div");
        row.className = "item";
        row.innerHTML = `
          <input class="input label" value="${e.label}" />
          <input class="input weight" type="number" min="0" step="1" value="${e.weight}"/>
          <input class="color" type="color" value="${e.color}"/>
          <div class="right">
            <button class="btn secondary mini up" title="위로">▲</button>
            <button class="btn secondary mini down" title="아래로">▼</button>
            <button class="btn danger mini del" title="삭제">삭제</button>
          </div>
        `;
        row.querySelector(".label").addEventListener("input", ev=>{
          e.label = ev.target.value; autoSave();
        });
        row.querySelector(".weight").addEventListener("input", ev=>{
          e.weight = +ev.target.value; autoSave();
        });
        row.querySelector(".color").addEventListener("input", ev=>{
          e.color = ev.target.value; autoSave();
        });
        row.querySelector(".del").addEventListener("click", ()=>{
          state.entries.splice(idx,1); renderList(); draw(); autoSave();
        });
        row.querySelector(".up").addEventListener("click", ()=>{
          if(idx>0){ const t = state.entries[idx]; state.entries[idx]=state.entries[idx-1]; state.entries[idx-1]=t; renderList(); draw(); autoSave(); }
        });
        row.querySelector(".down").addEventListener("click", ()=>{
          if(idx<state.entries.length-1){ const t = state.entries[idx]; state.entries[idx]=state.entries[idx+1]; state.entries[idx+1]=t; renderList(); draw(); autoSave(); }
        });
        el.appendChild(row);
      });
      renderBadges();
    }

    function autoSave(){
      saveAll();
      draw();
    }

    function draw(){
      fitCanvas(canvas);
      fitCanvas(confettiCanvas);
      const rect = canvas.getBoundingClientRect();
      const W = rect.width, H = rect.height;
      const R = Math.min(W,H)/2 - 18;
      ctx.clearRect(0,0,W,H);
      ctx.save();
      ctx.translate(W/2, H/2);
      ctx.rotate(state.rotation);

      // 배경 링
      ctx.beginPath();
      ctx.arc(0,0,R+8,0,TAU);
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.lineWidth = 16;
      ctx.stroke();

      const totalWeight = state.entries.reduce((s,e)=> s + Math.max(0,+e.weight||0), 0) || 1;
      // 각도 배분
      let start = -Math.PI/2; // 12시 방향부터
      const angles = [];
      for(const e of state.entries){
        const w = Math.max(0,+e.weight||0);
        const a = TAU * (w/totalWeight || 0);
        angles.push({start, end: start+a});
        start += a;
      }

      // 섹터
      state.ticks.lastIndex = -1;
      const fontSize = Math.max(12, Math.min(20, R*0.08));
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `600 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;

      angles.forEach((ang, i)=>{
        const e = state.entries[i];
        if(ang.end===ang.start) return;
        // 섹터 면
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,R, ang.start, ang.end);
        ctx.closePath();
        // 색
        const grd = ctx.createLinearGradient(0,0, Math.cos((ang.start+ang.end)/2)*R, Math.sin((ang.start+ang.end)/2)*R);
        grd.addColorStop(0, e.color);
        grd.addColorStop(1, shade(e.color, -12));
        ctx.fillStyle = grd;
        ctx.fill();

        // 경계선
        ctx.strokeStyle = "rgba(0,0,0,.25)";
        ctx.lineWidth = 1;
        ctx.stroke();

        // 라벨
        const mid = (ang.start + ang.end)/2;
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(R*0.62, 0);
        ctx.rotate(Math.PI/2);
        // 텍스트 배경 리본
        const label = e.label || "";
        const metrics = ctx.measureText(label);
        const w = Math.min(R*0.95, metrics.width + 20);
        ctx.fillStyle = "rgba(0,0,0,.25)";
        roundRect(ctx, -w/2, -fontSize*0.9, w, fontSize*1.5, 6);
        ctx.fill();
        // 텍스트
        ctx.fillStyle = "#fff";
        clipText(ctx, label, w-16);
        ctx.restore();
      });

      // 허브
      ctx.beginPath();
      ctx.fillStyle = "#0b0e1b";
      ctx.arc(0,0,48,0,TAU);
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.stroke();

      ctx.restore();
    }

    function shade(hex, amt){
      // hex -> 약간 어둡게 또는 밝게
      let c = hex.replace("#","");
      if(c.length===3) c = c.split("").map(x=>x+x).join("");
      const n = parseInt(c,16);
      let r = (n>>16)&255, g=(n>>8)&255, b=n&255;
      r = clamp(r + Math.round(2.55*amt), 0,255);
      g = clamp(g + Math.round(2.55*amt), 0,255);
      b = clamp(b + Math.round(2.55*amt), 0,255);
      return "#" + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
    }
    function roundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y, x+w,y+h, rr);
      ctx.arcTo(x+w,y+h, x,y+h, rr);
      ctx.arcTo(x,y+h, x,y, rr);
      ctx.arcTo(x,y, x+w,y, rr);
      ctx.closePath();
    }
    function clipText(ctx, text, maxW){
      // 간단한 말줄임
      let t = text;
      while(ctx.measureText(t).width > maxW && t.length>1){
        t = t.slice(0, -2) + "…";
      }
      ctx.fillText(t, 0, 0);
    }

    // ---------- 스핀 ----------
    function planSpin(){
      if(state.entries.length===0) return null;
      // 1) 가중치로 대상 선택
      const pick = choiceWeighted(state.entries);
      if(pick.index<0) return null;

      // 2) 각도 맵 생성
      const totalWeight = state.entries.reduce((s,e)=> s + Math.max(0,+e.weight||0), 0) || 1;
      let start = -Math.PI/2;
      const spans = [];
      for(const e of state.entries){
        const w = Math.max(0,+e.weight||0);
        const a = TAU * (w/totalWeight || 0);
        spans.push([start, start+a]);
        start += a;
      }
      const [s,e] = spans[pick.index];
      const width = e - s;
      if(width<=0){
        return null;
      }
      // 3) 섹터 안 랜덤 위치 선택
      const margin = Math.min(width*0.08, rad(3));
      const theta = rand(s+margin, e-margin); // 최종 섹터 중앙이 아니라 내부 임의 지점
      // 4) 포인터는 -PI/2 방향을 가리킴. 회전값 r에서 포인터 아래의 원판 각도는 (-PI/2 - r).
      //    따라서 (-PI/2 - r) == theta (mod TAU) 이어야 하므로 r == -PI/2 - theta + k*TAU
      const spins = Math.round(rand(state.options.spinsMin, state.options.spinsMax));
      const base = -Math.PI/2 - theta;
      // r을 현재 rotation보다 커지도록 조정
      let rTarget = base;
      // 현재 rotation보다 충분히 큰 k*TAU 더하기
      const need = state.rotation + spins*TAU;
      while(rTarget < need) rTarget += TAU;
      const dur = clamp(+state.options.duration || 6, 2, 20);

      return { index: pick.index, theta, rotationTarget: rTarget, duration: dur };
    }

    function spin(){
      if(state.spinning) return;
      if(state.entries.length===0) return;

      const plan = planSpin();
      if(!plan) return;
      state.spinning = true;
      state.target = {
        index: plan.index,
        rotationStart: state.rotation,
        rotationTarget: plan.rotationTarget,
        duration: plan.duration,
        t0: performance.now()
      };
      $("#resultText").textContent = "회전 중…";
      $("#hub").textContent = "…";
      animate();
    }

    function stopNow(){
      if(!state.spinning || !state.target) return;
      // 남은 애니메이션을 즉시 완료
      state.rotation = state.target.rotationTarget;
      finishSpin();
    }

    function animate(){
      if(!state.spinning || !state.target) return;
      const {t0, duration, rotationStart, rotationTarget} = state.target;
      const now = performance.now();
      const t = clamp((now - t0)/ (duration*1000), 0, 1);
      const k = easeOutCubic(t);
      const rot = lerp(rotationStart, rotationTarget, k);
      const prev = state.rotation;
      state.rotation = rot;

      // 틱 사운드: 포인터 아래의 섹터 인덱스가 변할 때 발생
      const idx = indexUnderPointer();
      if(idx !== state.ticks.lastIndex){
        if(state.ticks.lastIndex !== -1) tick();
        state.ticks.lastIndex = idx;
      }

      draw();
      confetti.update(1/60);
      confetti.draw();

      if(t<1){
        state.anim = requestAnimationFrame(animate);
      }else{
        finishSpin();
      }
    }

    function indexUnderPointer(){
      if(state.entries.length===0) return -1;
      // 포인터 아래 원판 각도 = (-PI/2 - rotation) mod TAU
      const pointerAngle = norm(-Math.PI/2 - state.rotation);
      // 섹터 경계 계산
      const totalWeight = state.entries.reduce((s,e)=> s + Math.max(0,+e.weight||0), 0) || 1;
      let start = -Math.PI/2;
      for(let i=0;i<state.entries.length;i++){
        const w = Math.max(0,+state.entries[i].weight||0);
        const a = TAU * (w/totalWeight || 0);
        const end = start + a;
        if(inArc(pointerAngle, start, end)) return i;
        start = end;
      }
      return -1;
    }
    const norm = a => {
      let x = a % TAU;
      if(x < 0) x += TAU;
      return x;
    };
    function inArc(a, s, e){
      // s<=a<e assuming no wrap because we build sequentially
      return a >= s && a < e;
    }

    function finishSpin(){
      state.spinning = false;
      cancelAnimationFrame(state.anim);
      state.anim = null;
      draw();

      const idx = indexUnderPointer();
      const winner = state.entries[idx];
      const time = new Date().toLocaleString();
      $("#hub").textContent = "SPIN";
      $("#resultText").innerHTML = winner
        ? `<span class="ok">"${winner.label}"</span> 당첨!`
        : "결과 없음";

      state.log.unshift({ time, label: winner?.label || "N/A", color: winner?.color || "#888" });
      state.log = state.log.slice(0, 200);
      renderLog();
      saveAll();

      if(state.options.confetti && winner){
        confetti.spawn(120, winner.color);
        let t = 0;
        const burst = ()=>{
          t++;
          confetti.update(1/60);
          confetti.draw();
          if(t<120) requestAnimationFrame(burst);
        };
        burst();
      }
    }

    function renderLog(){
      const el = $("#log");
      el.innerHTML = state.log.map(item=>`
        <div class="log-item">
          <span>${item.time}</span>
          <span style="display:inline-flex;align-items:center;gap:8px">
            <i style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${item.color}"></i>
            ${item.label}
          </span>
        </div>
      `).join("");
    }

    // ---------- 이벤트 ----------
    $("#add").addEventListener("click", ()=>{
      const label = $("#label").value.trim();
      const weight = +$("#weight").value || 1;
      const color = $("#color").value || randColor();
      if(!label){ $("#label").classList.add("danger-outline"); setTimeout(()=>$("#label").classList.remove("danger-outline"), 800); return; }
      state.entries.push({label, weight: Math.max(0, Math.floor(weight)), color});
      $("#label").value = "";
      $("#weight").value = "1";
      $("#color").value = randColor();
      renderList(); draw(); autoSave();
    });
    $("#randColor").addEventListener("click", ()=>{
      $("#color").value = randColor();
    });
    $("#reset").addEventListener("click", ()=>{
      if(!confirm("모든 항목, 기록을 초기화할까요?")) return;
      state.entries = [];
      state.log = [];
      state.rotation = 0;
      renderList(); renderLog(); draw(); saveAll();
      $("#resultText").textContent = "대기 중…";
    });
    $("#shuffle").addEventListener("click", ()=>{
      for(const e of state.entries){ e.color = randColor(); }
      renderList(); draw(); autoSave();
    });
    $("#saveNow").addEventListener("click", saveAll);

    // 옵션
    $("#duration").addEventListener("input", ev=>{
      state.options.duration = +ev.target.value || 6; autoSave();
    });
    $("#spinsMin").addEventListener("input", ev=>{
      state.options.spinsMin = Math.floor(+ev.target.value||5); autoSave();
    });
    $("#spinsMax").addEventListener("input", ev=>{
      state.options.spinsMax = Math.floor(+ev.target.value||8); autoSave();
    });
    $("#sound").addEventListener("change", ev=>{
      state.options.sound = !!ev.target.checked; autoSave();
    });
    $("#confetti").addEventListener("change", ev=>{
      state.options.confetti = !!ev.target.checked; autoSave();
    });
    $("#dark").addEventListener("change", ev=>{
      state.options.dark = !!ev.target.checked;
      document.documentElement.style.setProperty("--bg", state.options.dark ? "#0f1220" : "#f6f7fb");
      document.documentElement.style.setProperty("--panel", state.options.dark ? "#161a2f" : "#ffffff");
      document.documentElement.style.setProperty("--text", state.options.dark ? "#e6e9f4" : "#1e2430");
      document.documentElement.style.setProperty("--muted", state.options.dark ? "#a3aac2" : "#667084");
      autoSave();
    });

    $("#spin").addEventListener("click", spin);
    $("#stop").addEventListener("click", stopNow);
    window.addEventListener("keydown", ev=>{
      if(ev.code==="Space"){ ev.preventDefault(); state.spinning ? stopNow() : spin(); }
    });
    window.addEventListener("resize", ()=>{
      draw();
      confetti.update(0);
      confetti.draw();
    });

    function randColor(){
      const h = Math.floor(Math.random()*360);
      const s = 75 + Math.floor(Math.random()*20);
      const l = 50 + Math.floor(Math.random()*10);
      // hsl -> hex 변환(대략)
      const hex = hslToHex(h, s/100, l/100);
      return hex;
    }
    function hslToHex(h, s, l) {
      const a = s * Math.min(l, 1 - l);
      const f = n => {
        const k = (n + h/30) % 12;
        const c = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * c).toString(16).padStart(2, "0");
      };
      return `#${f(0)}${f(8)}${f(4)}`;
    }

    // ---------- 초기화 ----------
    loadAll();
    $("#duration").value = state.options.duration;
    $("#spinsMin").value = state.options.spinsMin;
    $("#spinsMax").value = state.options.spinsMax;
    $("#sound").checked = state.options.sound;
    $("#confetti").checked = state.options.confetti;
    $("#dark").checked = state.options.dark;
    if(!state.options.dark){
      document.documentElement.style.setProperty("--bg", "#f6f7fb");
      document.documentElement.style.setProperty("--panel", "#ffffff");
      document.documentElement.style.setProperty("--text", "#1e2430");
      document.documentElement.style.setProperty("--muted", "#667084");
    }
    renderList();
    renderLog();
    draw();

  })();
  </script>
</body>
  </html>
