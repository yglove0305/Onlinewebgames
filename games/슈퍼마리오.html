<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>모바일 Canvas Mario-like</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="theme-color" content="#87CEEB" />
  <style>
    :root {
      --ui: #111;
      --bg: #87CEEB;
      --panel: rgba(255,255,255,0.75);
      --btn: #ffffff;
      --btn-border: #222;
      --shadow: rgba(0,0,0,0.25);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(#87CEEB, #b6e1ff 60%, #e6f5ff 100%);
      color: var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      overscroll-behavior: none;
    }
    #wrap {
      position: relative;
      display: grid;
      place-items: center;
      width: 100%;
      height: 100%;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 4px solid #222;
      background: transparent;
      max-width: 100vw;
      max-height: 100vh;
      border-radius: 10px;
      box-shadow: 0 10px 30px var(--shadow);
      touch-action: none;
    }
    /* HUD bar */
    .hint {
      position: fixed; left: 12px; right: 12px; top: env(safe-area-inset-top, 10px);
      text-align: center; color: #06395a; font-size: 12px; opacity: 0.9; pointer-events: none;
      text-shadow: 0 1px 0 #fff;
    }

    /* Mobile controls */
    .controls {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }
    .cluster {
      position: absolute;
      bottom: calc(10px + env(safe-area-inset-bottom, 0px));
      display: flex; gap: 10px;
      pointer-events: auto;
      user-select: none;
    }
    .left {
      left: 10px;
      align-items: center;
    }
    .right {
      right: 10px;
      align-items: center;
    }
    .btn {
      background: var(--btn);
      border: 3px solid var(--btn-border);
      border-radius: 16px;
      min-width: 64px;
      min-height: 64px;
      padding: 10px 14px;
      text-align: center;
      font-weight: 800;
      font-size: 20px;
      line-height: 1;
      box-shadow: 0 6px 0 #222;
      transition: transform 0.02s ease;
      touch-action: manipulation;
    }
    .btn.small { min-width: 48px; min-height: 48px; font-size: 16px; border-radius: 12px; }
    .btn:active, .btn.active {
      transform: translateY(4px);
      box-shadow: 0 2px 0 #222;
    }
    .ghost {
      opacity: 0.75;
      background: rgba(255,255,255,0.9);
    }

    /* Top-right action buttons */
    .topbar {
      position: fixed;
      top: calc(10px + env(safe-area-inset-top, 0px)); right: 10px;
      display: flex; gap: 8px;
      pointer-events: auto;
    }

    /* Pause overlay */
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      background: rgba(0,0,0,0.5);
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .overlay.show { display: flex; }
    .panel {
      background: var(--panel);
      border: 2px solid #222;
      border-radius: 12px;
      padding: 16px;
      width: min(90vw, 420px);
      box-shadow: 0 10px 30px var(--shadow);
    }
    .panel h3 { margin: 0 0 8px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    .row .btn { flex: 1; }

    /* Rotate hint (portrait) */
    .rotate {
      position: fixed; inset: 0;
      display: none; place-items: center;
      background: rgba(0,0,0,0.4);
      z-index: 5; pointer-events: none;
    }
    .rotate.show { display: grid; }
    .rotate .card {
      background: var(--panel);
      border: 2px solid #222;
      border-radius: 12px; padding: 12px 16px;
      text-align: center; max-width: 80vw;
    }

    @media (min-width: 900px) {
      .btn { min-width: 56px; min-height: 56px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540" aria-label="게임 화면"></canvas>
  </div>

  <div class="hint">모바일: 좌/우 이동, A 점프, B 달리기 | 상단: ⏸ 일시정지, ⛶ 전체화면 | F1 디버그, R 재시작</div>

  <!-- Controls -->
  <div class="controls" aria-label="가상 컨트롤러">
    <div class="cluster left">
      <div class="btn ghost" data-key="ArrowLeft" aria-label="왼쪽">◀</div>
      <div class="btn ghost" data-key="ArrowRight" aria-label="오른쪽">▶</div>
    </div>
    <div class="cluster right">
      <div class="btn" data-key="KeyZ" aria-label="점프">A</div>
      <div class="btn" data-key="KeyX" aria-label="달리기">B</div>
    </div>
  </div>

  <!-- Topbar actions -->
  <div class="topbar">
    <button class="btn small" id="btnPause" aria-label="일시정지">⏸</button>
    <button class="btn small" id="btnFS" aria-label="전체화면">⛶</button>
  </div>

  <!-- Pause overlay -->
  <div class="overlay" id="pauseOverlay" role="dialog" aria-modal="true">
    <div class="panel">
      <h3>일시정지</h3>
      <div>계속하시겠어요?</div>
      <div class="row" style="margin-top:12px;">
        <button class="btn" id="btnResume">계속</button>
        <button class="btn" id="btnRestart">재시작</button>
      </div>
      <div style="margin-top:10px; font-size:12px; opacity:0.8;">팁: 점프(A)시 길게 누르면 더 높이 뜁니다.</div>
    </div>
  </div>

  <!-- Rotate portrait hint -->
  <div class="rotate" id="rotateHint">
    <div class="card">가로 화면에서 가장 잘 보입니다. 화면을 회전해 주세요.</div>
  </div>

  <script>
  ;(() => {
    // =========================
    // Constants and utilities
    // =========================
    const TILE = 16;
    const SCALE = 3;
    const GRAVITY = 2100;
    const WALK_SPEED = 130;
    const RUN_SPEED = 210;
    const JUMP_SPEED = 600;
    const MAX_FALL = 900;

    const COLORS = {
      skyTop: '#87CEEB', skyMid: '#b6e1ff', skyBot: '#e6f5ff',
      ground: '#b8682a', dirt: '#7a3e12', grass: '#2e9f3f',
      pipe: '#2bb853', block: '#c89b3c', blockShade: '#a57f30',
      brick: '#b4552b', brickDark: '#8d3f20', question: '#e0b84a', qDark: '#b89035',
      coin: '#FFD34E', coinDark: '#caa436',
      player: '#f44336', playerCap: '#b71c1c', playerBig: '#ff7043',
      enemy: '#7b4a1e', enemyDark: '#5a3716',
      flag: '#2ecc71', flagPole: '#cccccc',
    };

    const RNG = (seed => () => (seed = (seed * 1664525 + 1013904223) >>> 0) / 2**32)(0xA11CE);

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const haptic = (ms=15) => { try { if (navigator.vibrate) navigator.vibrate(ms); } catch {} };

    // =========================
    // Level data (mutable copy from template)
    // =========================
    const LEVEL_TEMPLATE = `
................................................................................................................................................................................................................
................................................................................................................................................................................................................
......................................................................................C...........................................................................................................................
.......................C.................................................C.........................................................................................................................
................................................................................................................................................................................................................
.................C............................................................B....?....M.................C.....................B.B.B...............................................................
.............................................B.B..............C.........................B............................................................C..............................................
..............P....................1.2.................................1.2.........................................................................................................................
###############################...3.4..................B....?....M....3.4...............#######..............1.2........................................B....?....M..........#######................
===============================...3.4..................................3.4==============.=======.=============3.4==================......................3.4=================.=======.==============
===============================...3.4..................................3.4==============.=======.=============3.4==================......................3.4=================.=======.==============
===============================...3.4..................................3.4==============.=======.=============3.4==================......................3.4=================.=======.==============
..................................3.4........G.......C.........G......3.4..................................G.............C.................G......................................................
###############################################################################################################################################################################.................|..
================================================================================================================================================================================.................|..
================================================================================================================================================================================.................|..
================================================================================================================================================================================.................|..
`.trim();

    const LEVEL_ROWS = LEVEL_TEMPLATE.split('\n');
    const MAP_H = LEVEL_ROWS.length;
    const MAP_W = LEVEL_ROWS[0].length;
    const SOLIDS = new Set(['#','1','2','3','4','B','?','M']);

    const inBounds = (tx,ty) => tx>=0 && ty>=0 && tx<MAP_W && ty<MAP_H;
    const tileAt = (tx,ty) => inBounds(tx,ty) ? LEVEL_ROWS[ty][tx] : '#';
    const isSolidTile = ch => SOLIDS.has(ch);
    const keyOf = (tx,ty) => `${tx},${ty}`;

    // =========================
    // Vector and Rect
    // =========================
    class Vec2 {
      constructor(x=0,y=0){ this.x=x; this.y=y; }
      set(x,y){ this.x=x; this.y=y; return this; }
      copy(){ return new Vec2(this.x,this.y); }
    }
    class Rect {
      constructor(x=0,y=0,w=0,h=0){ this.x=x; this.y=y; this.w=w; this.h=h; }
      get left(){ return this.x; } get right(){ return this.x+this.w; }
      get top(){ return this.y; } get bottom(){ return this.y+this.h; }
      intersects(r){ return this.right>r.left && this.left<r.right && this.bottom>r.top && this.top<r.bottom; }
    }

    // =========================
    // Input (keyboard + mobile)
    // =========================
    const input = {
      keys: new Map(),
      down(k){ return this.keys.get(k) >= 1; },
      press(k){ return this.keys.get(k) === 1; },
      set(k, down){
        const v = this.keys.get(k) || 0;
        if (down) { this.keys.set(k, v ? 2 : 1); } else { this.keys.set(k, 0); }
      },
      update(){ for (const [k,v] of this.keys) if (v===1) this.keys.set(k,2); },
      clear(){ this.keys.clear(); }
    };

    addEventListener('keydown', e => {
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' '].includes(e.key)) e.preventDefault();
      input.set(e.code, true);
      if (e.code === 'F1') debug.toggle();
      if (e.code === 'KeyR') initGame();
    }, {passive:false});
    addEventListener('keyup', e => input.set(e.code, false), {passive:true});

    // Mobile buttons
    for (const el of document.querySelectorAll('.btn[data-key]')){
      const code = el.getAttribute('data-key');
      const set = (down) => (ev) => { ev.preventDefault(); input.set(code, down); el.classList.toggle('active', down); };
      el.addEventListener('touchstart', set(true), {passive:false});
      el.addEventListener('touchend', set(false), {passive:false});
      el.addEventListener('touchcancel', set(false), {passive:false});
      el.addEventListener('mousedown', set(true));
      el.addEventListener('mouseup', set(false));
      el.addEventListener('mouseleave', set(false));
    }

    // Topbar: pause, fullscreen
    const pauseOverlay = document.getElementById('pauseOverlay');
    const btnPause = document.getElementById('btnPause');
    const btnFS = document.getElementById('btnFS');
    const btnResume = document.getElementById('btnResume');
    const btnRestart = document.getElementById('btnRestart');

    let paused = false;
    const setPaused = (on) => {
      paused = on;
      pauseOverlay.classList.toggle('show', on);
    };
    btnPause.addEventListener('click', () => setPaused(!paused));
    btnResume.addEventListener('click', () => setPaused(false));
    btnRestart.addEventListener('click', () => { setPaused(false); initGame(); });

    btnFS.addEventListener('click', async () => {
      const el = document.documentElement;
      try {
        if (!document.fullscreenElement) await el.requestFullscreen?.();
        else await document.exitFullscreen?.();
      } catch {}
    });

    // Rotate hint
    const rotateHint = document.getElementById('rotateHint');
    const updateRotateHint = () => {
      const isPortrait = window.innerHeight > window.innerWidth;
      rotateHint.classList.toggle('show', isPortrait);
    };
    addEventListener('resize', updateRotateHint);
    updateRotateHint();

    // =========================
    // Camera
    // =========================
    const camera = {
      x:0,y:0,w:320,h:180,
      followX(targetX, dt){
        const target = clamp(targetX - this.w/2, 0, MAP_W*TILE - this.w);
        this.x += (target - this.x) * clamp(dt*6, 0, 1);
      },
      followY(targetY, dt){
        const target = clamp(targetY - this.h/2, 0, MAP_H*TILE - this.h);
        this.y += (target - this.y) * clamp(dt*6, 0, 1);
      }
    };

    // =========================
    // Entities and state
    // =========================
    const entities = [];
    const particles = [];
    const coins = [];
    const qblocks = new Map();
    const bricks = new Map();
    const spawns = { goombas: [], coins: [], player: new Vec2(32,0), flag: null };

    class Entity {
      constructor(x,y,w,h){
        this.pos = new Vec2(x,y);
        this.vel = new Vec2(0,0);
        this.box = new Rect(x,y,w,h);
        this.onGround = false;
        this.alive = true;
        this.removed = false;
        this.facing = 1;
        this.type = 'entity';
      }
      aabb(){ this.box.x=this.pos.x; this.box.y=this.pos.y; return this.box; }
      update(dt){}
      draw(g){}
      remove(){ this.removed = true; }
    }

    class Player extends Entity {
      constructor(x,y){
        super(x,y, 12, 14);
        this.type='player';
        this.spawn = new Vec2(x,y);
        this.coyote = 0;
        this.jumpBuffer = 0;
        this.big = false;
        this.inv = 0;
        this.score = 0;
        this.coins = 0;
        this.time = 300;
        this.dead = false;
        this.goal = false;
        this.speedMult = 1;
      }
      get speedCap(){ return (input.down('KeyX') ? RUN_SPEED : WALK_SPEED) * this.speedMult; }

      kill(){
        if (this.inv > 0) return;
        if (this.big){
          this.big = false;
          this.inv = 2.0;
          haptic(60);
        } else {
          this.dead = true;
          this.vel.set(0,-450);
          this.onGround = false;
          haptic([40,40,60]);
        }
      }
      stompEnemy(){
        this.score += 100;
        this.vel.y = -420;
        this.onGround = false;
        haptic(20);
      }
      giveCoin(n=1){
        this.coins += n;
        this.score += 100 * n;
        haptic(10);
      }
      giveMushroom(){
        if (!this.big){
          this.big = true;
          this.pos.y -= 8;
          haptic(30);
        } else {
          this.score += 1000;
        }
      }
      update(dt){
        if (this.dead){
          this.vel.y += GRAVITY*dt;
          this.vel.y = Math.min(this.vel.y, MAX_FALL);
          this.pos.y += this.vel.y * dt;
          if (this.pos.y > (MAP_H*TILE + 200)) this.respawn();
          return;
        }
        if (this.goal){
          this.vel.x = 60;
          this.vel.y += GRAVITY*dt;
          this.vel.y = Math.min(this.vel.y, MAX_FALL);
          moveAndCollide(this, dt);
          return;
        }

        this.coyote = Math.max(0, this.coyote - dt);
        this.jumpBuffer = Math.max(0, this.jumpBuffer - dt);
        this.inv = Math.max(0, this.inv - dt);

        const left = input.down('ArrowLeft');
        const right = input.down('ArrowRight');
        const jumpPressed = input.press('KeyZ') || input.press('Space') || input.press('ArrowUp');
        const jumpHeld = input.down('KeyZ') || input.down('Space') || input.down('ArrowUp');

        const dir = (right?1:0) - (left?1:0);
        if (dir !== 0) this.facing = dir;

        const desired = dir * this.speedCap;
        if (dir !== 0){
          this.vel.x += (desired - this.vel.x) * clamp(dt*8, 0, 1);
          if (Math.abs(this.vel.x - desired) < 1) this.vel.x = desired;
        } else {
          const friction = this.onGround ? 1400 : 300;
          const s = Math.max(0, Math.abs(this.vel.x) - friction*dt);
          this.vel.x = s * Math.sign(this.vel.x);
        }
        if (Math.abs(this.vel.x) > this.speedCap) this.vel.x = this.speedCap * Math.sign(this.vel.x);

        if (jumpPressed) { this.jumpBuffer = 0.12; haptic(12); }
        if (this.onGround) this.coyote = 0.12;

        if (this.jumpBuffer > 0 && this.coyote > 0){
          this.vel.y = -JUMP_SPEED;
          this.onGround = false;
          this.coyote = 0;
          this.jumpBuffer = 0;
        }
        if (!jumpHeld && this.vel.y < -120){
          this.vel.y = Math.max(this.vel.y, -120);
        }

        this.vel.y += GRAVITY*dt;
        this.vel.y = Math.min(this.vel.y, MAX_FALL);
        moveAndCollide(this, dt);

        this.time -= dt;
        if (this.time <= 0 && !this.dead){
          this.kill();
        }
      }
      respawn(){
        this.dead = false; this.inv = 2.0; this.big = false;
        this.pos.set(this.spawn.x, this.spawn.y);
        this.vel.set(0,0);
        this.goal = false;
        this.time = 300;
        camera.x = clamp(this.pos.x - camera.w/2, 0, MAP_W*TILE - camera.w);
      }
      draw(g){
        // shadow
        g.fillStyle = 'rgba(0,0,0,0.2)';
        g.fillRect(Math.floor(this.pos.x - camera.x), Math.floor(this.pos.y - camera.y + (this.big?16:12)), this.box.w, 3);

        const blink = (this.inv > 0) ? ((Math.floor(perf*10)%2)===0) : true;
        if (!blink) return;

        const px = Math.floor(this.pos.x - camera.x);
        const py = Math.floor(this.pos.y - camera.y);
        const w = this.box.w;
        const h = this.big ? 28 : 14;

        g.fillStyle = this.big ? COLORS.playerBig : COLORS.player;
        g.fillRect(px, py - (this.big?14:0), w, h);
        g.fillStyle = COLORS.playerCap;
        g.fillRect(px, py - (this.big?18:4), w, 4);
        g.fillStyle = '#ffd7c2';
        g.fillRect(px+2, py - (this.big?12:0), w-4, 4);
      }
    }

    class Goomba extends Entity {
      constructor(x,y){ super(x,y,14,12); this.type='goomba'; this.vel.x = -40; this.squashed = 0; }
      update(dt){
        if (this.squashed > 0){
          this.squashed -= dt; if (this.squashed <= 0) this.remove(); return;
        }
        this.vel.y += GRAVITY*dt; this.vel.y = Math.min(this.vel.y, MAX_FALL);

        const ahead = this.pos.x + (this.vel.x>0 ? this.box.w+1 : -1);
        const footY = this.pos.y + this.box.h + 1;
        const tx = Math.floor(ahead / TILE), ty = Math.floor(footY / TILE);
        const under = tileAt(tx,ty);
        if (!isSolidTile(under)) this.vel.x *= -1;

        moveAndCollide(this, dt);
        if (this._hitWall) this.vel.x *= -1;
      }
      stomp(){
        this.squashed = 0.25; this.vel.set(0,0);
        particles.push(new Poof(this.pos.x+this.box.w/2, this.pos.y+this.box.h/2, COLORS.enemy));
      }
      draw(g){
        if (this.squashed > 0){
          g.fillStyle = COLORS.enemyDark;
          g.fillRect(Math.floor(this.pos.x - camera.x), Math.floor(this.pos.y - camera.y + this.box.h-4), this.box.w, 4);
          return;
        }
        const px = Math.floor(this.pos.x - camera.x), py = Math.floor(this.pos.y - camera.y);
        g.fillStyle = COLORS.enemy; g.fillRect(px, py, this.box.w, this.box.h);
        g.fillStyle = COLORS.enemyDark; g.fillRect(px+2, py+2, this.box.w-4, this.box.h-4);
      }
    }

    class Mushroom extends Entity {
      constructor(x,y){ super(x,y,12,12); this.type='mushroom'; this.vel.x=40; this.spawnRise=0; }
      update(dt){
        if (this.spawnRise < TILE){
          const step = 80*dt; this.pos.y -= step; this.spawnRise += step; return;
        }
        this.vel.y += GRAVITY*dt; this.vel.y = Math.min(this.vel.y, MAX_FALL);
        moveAndCollide(this, dt);
        if (this._hitWall) this.vel.x *= -1;
        if (player.aabb().intersects(this.aabb())){
          player.giveMushroom(); player.score += 1000;
          particles.push(new Poof(this.pos.x+6, this.pos.y+6, COLORS.question));
          this.remove();
        }
      }
      draw(g){
        const px = Math.floor(this.pos.x - camera.x), py = Math.floor(this.pos.y - camera.y);
        g.fillStyle = COLORS.question; g.fillRect(px, py, this.box.w, this.box.h);
        g.fillStyle = COLORS.qDark; g.fillRect(px+2, py+2, this.box.w-4, this.box.h-4);
      }
    }

    class Poof {
      constructor(x,y,color){ this.x=x; this.y=y; this.t=0; this.color=color; }
      update(dt){ this.t+=dt; if (this.t>0.4) this.dead=true; }
      draw(g){
        const a = clamp(1 - this.t/0.4, 0, 1);
        g.fillStyle = `rgba(0,0,0,${0.1*a})`;
        g.fillRect(Math.floor(this.x - camera.x)-8, Math.floor(this.y - camera.y)-2, 16, 4);
        const r = 2 + this.t*12;
        g.strokeStyle = this.color; g.globalAlpha = a;
        g.beginPath(); g.arc(Math.floor(this.x - camera.x), Math.floor(this.y - camera.y), r, 0, Math.PI*2); g.stroke();
        g.globalAlpha = 1;
      }
    }

    // =========================
    // Level parse and objects
    // =========================
    function parseLevel(){
      qblocks.clear(); bricks.clear();
      spawns.goombas.length = 0;
      spawns.coins.length = 0;
      spawns.flag = null;

      for (let y=0;y<MAP_H;y++){
        for (let x=0;x<MAP_W;x++){
          const ch = LEVEL_ROWS[y][x];
          if (ch==='G') spawns.goombas.push({x:x*TILE, y:(y-1)*TILE});
          if (ch==='C') spawns.coins.push({x:x*TILE+4, y:y*TILE+4});
          if (ch==='?') qblocks.set(keyOf(x,y), {type:'coin', used:false, bounce:0});
          if (ch==='M') qblocks.set(keyOf(x,y), {type:'mushroom', used:false, bounce:0});
          if (ch==='B') bricks.set(keyOf(x,y), {bounce:0, broken:false});
          if (ch==='P') spawns.player = new Vec2(x*TILE, (y-1)*TILE);
          if (ch==='|') spawns.flag = {x:x*TILE+6, y: (y-12)*TILE};
        }
      }
    }

    class CoinObj {
      constructor(x,y){ this.x=x; this.y=y; this.t=0; this.taken=false; this.bob= RNG()*Math.PI*2; }
      update(dt){
        if (this.taken) return;
        this.t += dt;
        const r = new Rect(this.x, this.y-4, 8, 8);
        if (player.aabb().intersects(r)){
          this.taken = true; player.giveCoin(1); player.score += 200;
          particles.push(new Poof(this.x+4, this.y, COLORS.coin));
        }
      }
      draw(g){
        if (this.taken) return;
        const sy = Math.sin(this.bob + perf*2) * 2;
        const px = Math.floor(this.x - camera.x), py = Math.floor(this.y - camera.y + sy);
        g.fillStyle = COLORS.coin; g.fillRect(px, py, 8, 8);
        g.fillStyle = COLORS.coinDark; g.fillRect(px+2, py+2, 4, 4);
      }
    }

    // =========================
    // Collision and movement
    // =========================
    function moveAndCollide(e, dt){
      e._hitWall = false;

      e.pos.x += e.vel.x * dt;
      if (resolveTiles(e, true)){
        e._hitWall = true; e.vel.x = 0;
      }
      e.pos.y += e.vel.y * dt;
      const hitVert = resolveTiles(e, false);
      const wasGround = e.onGround;
      e.onGround = hitVert && e.vel.y >= 0;
      if (hitVert) e.vel.y = 0;
      if (e.type==='player' && e.onGround && !wasGround){
        particles.push(new Poof(e.pos.x + e.box.w/2, e.pos.y + e.box.h, COLORS.dirt));
      }
    }

    function resolveTiles(e, horizontal){
      const box = e.aabb();
      let collided = false;

      const startX = Math.floor((box.left - 2)/TILE)-1;
      const endX   = Math.floor((box.right + 2)/TILE)+1;
      const startY = Math.floor((box.top - 2)/TILE)-1;
      const endY   = Math.floor((box.bottom + 2)/TILE)+1;

      for (let ty=startY; ty<=endY; ty++){
        for (let tx=startX; tx<=endX; tx++){
          const ch = tileAt(tx,ty);
          if (!isSolidTile(ch)) continue;

          const rect = new Rect(tx*TILE, ty*TILE, TILE, TILE);
          if (!box.intersects(rect)) continue;

          const dx1 = box.right - rect.left, dx2 = rect.right - box.left;
          const dy1 = box.bottom - rect.top, dy2 = rect.bottom - box.top;
          const penX = Math.min(dx1, dx2), penY = Math.min(dy1, dy2);

          if (penX < penY){
            if (box.right > rect.left && box.left < rect.left) e.pos.x -= dx1; else e.pos.x += dx2;
            box.x = e.pos.x; collided = true;
          } else {
            if (box.bottom > rect.top && box.top < rect.top){
              e.pos.y -= dy1; // landed
            } else {
              e.pos.y += dy2; // bumped from below
              if (e.type==='player'){
                if (ch==='?' || ch==='M'){
                  const data = qblocks.get(keyOf(tx,ty));
                  if (data && !data.used){
                    data.bounce = 1;
                    if (data.type==='coin'){
                      player.giveCoin(1); data.used = true; bumpReplaceTile(tx,ty,'.');
                      particles.push(new Poof(tx*TILE+8, ty*TILE, COLORS.coin));
                    } else {
                      data.used = true; bumpReplaceTile(tx,ty,'.');
                      spawnMushroom(tx*TILE+2, ty*TILE+TILE-2);
                    }
                  }
                }
                if (ch==='B'){
                  const data = bricks.get(keyOf(tx,ty));
                  if (data && !data.broken){
                    data.bounce = 1;
                    if (player.big){
                      data.broken = true; bumpReplaceTile(tx,ty,'.'); breakBrick(tx,ty);
                      player.score += 50;
                    }
                  }
                }
              }
            }
            box.y = e.pos.y; collided = true;
          }
        }
      }
      return collided;
    }

    function bumpReplaceTile(tx,ty,to){
      const row = LEVEL_ROWS[ty];
      LEVEL_ROWS[ty] = row.slice(0,tx) + to + row.slice(tx+1);
    }
    function breakBrick(tx,ty){
      for (let i=0;i<8;i++){
        const ang = (i/8)*Math.PI*2;
        const spd = 90 + RNG()*120;
        const vx = Math.cos(ang)*spd, vy = Math.sin(ang)*spd - 100;
        particles.push({
          x: tx*TILE+8, y: ty*TILE+8, vx, vy, t:0,
          update(dt){ this.vy += GRAVITY*dt; this.x += this.vx*dt; this.y += this.vy*dt; this.t += dt; },
          draw(g){ g.fillStyle = COLORS.brick; g.fillRect(Math.floor(this.x - camera.x), Math.floor(this.y - camera.y), 3, 3); }
        });
      }
      haptic(20);
    }
    function spawnMushroom(x,y){ entities.push(new Mushroom(x,y)); }

    // =========================
    // Rendering
    // =========================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    function resizeCanvas(){
      // Logical camera size is fixed; scale canvas CSS size to fit viewport while keeping aspect
      const baseW = 320 * SCALE, baseH = 180 * SCALE;
      const maxW = Math.min(window.innerWidth - 12, 1280);
      const maxH = Math.min(window.innerHeight - 12, 720);
      const k = Math.min(maxW/baseW, maxH/baseH);
      canvas.style.width = Math.floor(baseW*k) + 'px';
      canvas.style.height = Math.floor(baseH*k) + 'px';
      camera.w = 320; camera.h = 180;
    }
    addEventListener('resize', resizeCanvas, {passive:true});

    function drawBackground(g){
      const grad = g.createLinearGradient(0,0,0,canvas.height);
      grad.addColorStop(0, COLORS.skyTop);
      grad.addColorStop(0.6, COLORS.skyMid);
      grad.addColorStop(1, COLORS.skyBot);
      g.fillStyle = grad; g.fillRect(0,0,canvas.width,canvas.height);
      g.globalAlpha = 0.8; drawCloudLayer(g, 0.2, 80, 0.6);
      g.globalAlpha = 0.6; drawCloudLayer(g, 0.5, 60, 1.0);
      g.globalAlpha = 1;
    }
    function drawCloudLayer(g, speed, yBase, scale){
      const t = perf * speed;
      for (let i=0;i<6;i++){
        const x = Math.floor(((i*240 - (camera.x*speed + t*50)) % (MAP_W*TILE)) - camera.x*0);
        const y = Math.floor(20 + yBase + (i%2)*15);
        drawCloud(g, x, y, scale);
      }
    }
    function drawCloud(g, x, y, s){
      g.fillStyle = 'rgba(255,255,255,0.9)';
      const w=40*s, h=14*s;
      g.beginPath(); g.ellipse(x, y, w*0.6, h*0.6, 0, 0, Math.PI*2); g.fill();
      g.beginPath(); g.ellipse(x+15*s, y+2*s, w*0.5, h*0.5, 0, 0, Math.PI*2); g.fill();
      g.beginPath(); g.ellipse(x-15*s, y+4*s, w*0.5, h*0.5, 0, 0, Math.PI*2); g.fill();
    }

    function drawTile(g, tx, ty, ch){
      const x = tx*TILE - camera.x|0, y = ty*TILE - camera.y|0;
      if (y > camera.h) return;

      switch (ch){
        case '#':
          g.fillStyle = COLORS.ground; g.fillRect(x,y,TILE,TILE);
          g.fillStyle = COLORS.dirt; g.fillRect(x,y+10,TILE,6);
          g.fillStyle = COLORS.grass; g.fillRect(x,y, TILE, 3);
          break;
        case '=':
          g.fillStyle = COLORS.dirt; g.globalAlpha = 0.3; g.fillRect(x,y,TILE,TILE); g.globalAlpha = 1; break;
        case '1': case '2': case '3': case '4':
          g.fillStyle = COLORS.pipe; g.fillRect(x,y,TILE,TILE);
          g.fillStyle = '#1c7c3b'; g.fillRect(x+2,y+2,TILE-4,TILE-4);
          if (ch==='1'||ch==='2'){ g.fillStyle = '#4ee387'; g.fillRect(x, y, TILE, 3); }
          break;
        case 'B': {
          const data = bricks.get(keyOf(tx,ty)); let by = (data && data.bounce>0) ? Math.sin(data.bounce*Math.PI)*3 : 0;
          g.save(); g.translate(0,-by);
          g.fillStyle = COLORS.brick; g.fillRect(x,y,TILE,TILE);
          g.fillStyle = COLORS.brickDark;
          for (let i=0;i<2;i++){ g.fillRect(x, y+i*8+7, TILE, 1); g.fillRect(x+7, y+i*8, 1, 7); }
          g.restore();
          break;
        }
        case '?':
        case 'M': {
          const data = qblocks.get(keyOf(tx,ty)); const used = data && data.used;
          const by = (data && data.bounce>0) ? Math.sin(data.bounce*Math.PI)*3 : 0;
          g.save(); g.translate(0,-by);
          g.fillStyle = used ? '#9e9e9e' : COLORS.question; g.fillRect(x,y,TILE,TILE);
          g.fillStyle = used ? '#6b6b6b' : COLORS.qDark; g.fillRect(x+2,y+2,TILE-4,TILE-4);
          if (!used){ g.fillStyle = '#fff'; g.fillRect(x+7,y+4,2,2); g.fillRect(x+6,y+6,2,2); g.fillRect(x+6,y+9,2,2); }
          g.restore();
          break;
        }
        default: break;
      }
    }

    // =========================
    // Game setup and loop
    // =========================
    let player;
    const debug = { on:false, toggle(){ this.on = !this.on; } };
    let last=0, perf=0;

    function initGame(){
      // Reset mutable rows from template
      const fresh = LEVEL_TEMPLATE.split('\n');
      for (let i=0;i<LEVEL_ROWS.length;i++) LEVEL_ROWS[i] = fresh[i];

      entities.length = 0; particles.length = 0; coins.length = 0;
      parseLevel();

      // Player
      player = new Player(spawns.player.x, spawns.player.y);

      // Enemies
      for (const g of spawns.goombas) entities.push(new Goomba(g.x, g.y));
      // Coins
      for (const c of spawns.coins) coins.push(new CoinObj(c.x, c.y));

      // Camera
      camera.x = clamp(player.pos.x - camera.w/2, 0, MAP_W*TILE - camera.w);
      camera.y = 0;
    }

    function handleInteractions(){
      for (const e of entities){
        if (e.removed) continue;
        if (e.type === 'goomba'){
          if (player.dead || player.goal) continue;
          if (player.aabb().intersects(e.aabb())){
            const vy = player.vel.y;
            if (vy > 70 && player.pos.y + player.box.h - 4 < e.pos.y){
              e.stomp(); player.stompEnemy();
            } else {
              player.kill();
            }
          }
        }
      }
    }

    function checkFlag(){
      if (!spawns.flag) return;
      const fx = spawns.flag.x, fy = spawns.flag.y;
      const rect = new Rect(fx-6, 0, 12, MAP_H*TILE);
      if (!player.goal && player.aabb().intersects(rect)){
        player.goal = true; player.score += 2000;
        player.pos.x = fx - 4; player.vel.x = 0; player.vel.y = 50;
        setTimeout(()=>{ player.speedMult = 0.6; }, 800);
      }
    }

    function update(dt){
      // Limit dt for stability on background tab resumes
      dt = Math.min(dt, 1/30);

      // Pause
      if (paused) { input.update(); return; }

      // Blocks bounces
      for (const [k,d] of qblocks){ if (d.bounce>0){ d.bounce -= dt*3; if (d.bounce<0) d.bounce=0; } }
      for (const [k,d] of bricks){ if (d.bounce>0){ d.bounce -= dt*3; if (d.bounce<0) d.bounce=0; } }

      player.update(dt);
      camera.followX(player.pos.x + player.box.w/2, dt);
      camera.followY(player.pos.y + player.box.h/2, dt);

      for (const e of entities) if (!e.removed) e.update(dt);
      for (const c of coins) c.update(dt);

      handleInteractions();

      for (let i=entities.length-1;i>=0;i--) if (entities[i].removed) entities.splice(i,1);
      for (const p of particles) p.update?.(dt);
      for (let i=particles.length-1;i>=0;i--) if (particles[i].dead || particles[i].t>2) particles.splice(i,1);

      checkFlag();
      input.update();
    }

    function drawHUD(g){
      const pad = 12;
      const box = (x,y,w,h,fill,stroke='#222')=>{
        g.fillStyle = fill; g.fillRect(x,y,w,h);
        g.strokeStyle = stroke; g.lineWidth = 2; g.strokeRect(x,y,w,h);
      };

      box(10, 10, canvas.width - 20, 40, 'rgba(255,255,255,0.75)');

      g.fillStyle = '#111';
      g.font = 'bold 18px ui-sans-serif';
      g.fillText(`SCORE: ${player.score.toString().padStart(6,'0')}`, 24, 36);

      g.fillStyle = COLORS.coin; g.fillRect(220, 18, 14, 14);
      g.fillStyle = COLORS.coinDark; g.fillRect(224, 22, 6, 6);
      g.fillStyle = '#111'; g.fillText(`x ${player.coins}`, 240, 32);

      const time = Math.max(0, Math.floor(player.time));
      g.fillText(`TIME: ${time}`, canvas.width - 160, 32);

      if (player.big){
        g.fillStyle = COLORS.playerBig; g.fillRect(340, 18, 24, 24);
        g.fillStyle = COLORS.playerCap; g.fillRect(340, 14, 24, 6);
      }

      g.textAlign = 'center';
      if (player.dead){
        g.fillStyle = 'rgba(0,0,0,0.6)'; g.fillRect(0,0,canvas.width,canvas.height);
        g.fillStyle = '#fff'; g.font = 'bold 28px ui-sans-serif'; g.fillText('YOU DIED', canvas.width/2, canvas.height/2 - 10);
        g.font = '16px ui-sans-serif'; g.fillText('R 키 또는 재시작 버튼', canvas.width/2, canvas.height/2 + 16);
      } else if (player.goal){
        g.fillStyle = 'rgba(0,0,0,0.4)'; g.fillRect(0,0,canvas.width,canvas.height);
        g.fillStyle = '#fff'; g.font = 'bold 28px ui-sans-serif'; g.fillText('COURSE CLEAR!', canvas.width/2, canvas.height/2 - 10);
        g.font = '16px ui-sans-serif'; g.fillText('R 키 또는 재시작 버튼', canvas.width/2, canvas.height/2 + 16);
      }
      g.textAlign = 'start';
    }

    function draw(){
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBackground(ctx);

      const kx = canvas.width / (camera.w * SCALE);
      const ky = canvas.height / (camera.h * SCALE);
      const k = Math.min(kx, ky);
      ctx.translate((canvas.width - camera.w * SCALE * k)/2, (canvas.height - camera.h * SCALE * k)/2);
      ctx.scale(k, k);
      ctx.scale(SCALE, SCALE);

      const minTx = Math.max(0, Math.floor(camera.x / TILE) - 2);
      const maxTx = Math.min(MAP_W-1, Math.floor((camera.x + camera.w) / TILE) + 2);
      const minTy = Math.max(0, Math.floor(camera.y / TILE) - 2);
      const maxTy = Math.min(MAP_H-1, Math.floor((camera.y + camera.h) / TILE) + 2);

      for (let ty=minTy; ty<=maxTy; ty++){
        const row = LEVEL_ROWS[ty];
        for (let tx=minTx; tx<=maxTx; tx++){
          drawTile(ctx, tx, ty, row[tx]);
        }
      }

      if (spawns.flag){
        const fx = spawns.flag.x - camera.x|0;
        const fy = Math.floor(2*TILE - camera.y);
        ctx.fillStyle = COLORS.flagPole; ctx.fillRect(fx, fy, 4, 12*TILE);
        const flap = Math.sin(perf*3)*3;
        ctx.fillStyle = COLORS.flag; ctx.fillRect(fx+4, fy+4, 12+flap, 6);
      }

      for (const c of coins) c.draw(ctx);
      for (const e of entities) e.draw(ctx);
      player.draw(ctx);

      for (const p of particles) p.draw?.(ctx);

      if (debug.on){
        ctx.strokeStyle = 'rgba(255,0,0,0.6)';
        const b = player.aabb();
        ctx.strokeRect(Math.floor(b.x - camera.x), Math.floor(b.y - camera.y), b.w, b.h);
      }

      ctx.setTransform(1,0,0,1,0,0);
      drawHUD(ctx);
      ctx.restore();
    }

    // =========================
    // Main loop
    // =========================
    let rafId = 0, lastStamp = 0;
    function loop(t){
      if (!lastStamp) lastStamp = t;
      const dt = (t - lastStamp) / 1000;
      lastStamp = t; perf = t/1000;

      update(dt);
      draw();

      rafId = requestAnimationFrame(loop);
    }

    // =========================
    // Start
    // =========================
    function start(){
      resizeCanvas(); parseLevel(); initGame();
      cancelAnimationFrame(rafId); lastStamp = 0; requestAnimationFrame(loop);
    }
    start();

    // =========================
    // Coins init (after parse)
    // =========================
    // Already handled in initGame()

    // =========================
    // Helpers
    // =========================
    addEventListener('visibilitychange', () => {
      if (document.hidden) setPaused(true);
    });

    // =========================
    // Touch gestures (optional swipes)
    // =========================
    // 기본 가상 버튼으로 충분하지만, 화면 아무 곳에서 좌/우 스와이프 보조 입력 지원
    let touchStartX = null, touchActive = false;
    addEventListener('touchstart', (e) => {
      if (e.target.closest('.btn')) return; // handled by buttons
      if (e.touches.length===1){
        touchStartX = e.touches[0].clientX; touchActive = true;
      }
    }, {passive:true});
    addEventListener('touchmove', (e) => {
      if (!touchActive || e.target.closest('.btn')) return;
      if (!touchStartX) return;
      const dx = e.touches[0].clientX - touchStartX;
      const dead = 18;
      input.set('ArrowLeft', dx < -dead);
      input.set('ArrowRight', dx > dead);
    }, {passive:true});
    addEventListener('touchend', (e) => {
      if (!touchActive || e.target.closest('.btn')) return;
      touchActive = false; touchStartX = null;
      input.set('ArrowLeft', false); input.set('ArrowRight', false);
    }, {passive:true});

    // =========================
    // Draw clouds on background
    // =========================
    // already defined above

  })();
  </script>
</body>
</html>
```[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/nathandanielanderson/game-repo/tree/fb2d63661b58901337ebbeaa45c4142a6036defb/TopDownGame%2Fcode%2Fgame.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "1")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/sriayuw/lpmujikom/tree/3f24a99fe2fffbbd6b15eb8ab96d9fcce774c540/dashboard%2Fdompdf%2Fsrc%2FFrameReflower%2FText.php?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "2")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/gerowam/influence/tree/34e0c529c9778a8ce799acaec212d801178a6a7e/dtm-dim-rdim%2Fgsl%2Fgsl%2Frng%2Funi.c?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "3")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/idefiks1/trial/tree/3f5337059a814f6d5fc930c3b964f7624dd3296e/resources%2Fviews%2Fbiologyexample.blade.php?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "4")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/lindenb/jvarkit/tree/9510914989e462163fa190cbd7b086a1d44feab9/docs%2FBamSliceBed.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "5")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/goudjanoueddie/DanyJump/tree/5fd25e76c350a854fb3ae2ff27f02a17a4ae8c3d/app%2Fsrc%2Fmain%2Fjava%2Forg%2Fjdeveloper%2Fdanyjump%2FLevelVI.java?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "6")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/gbersac/gomoku_42/tree/91eb8415c8b5a3a8366e68e2c8782ce601004f68/src%2Fai%2Ftest_decision.rs?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "7")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/SharonBarak/Florida-High-School-Programming-Series/tree/97ba650d95385d354c09ab7c2d42ad84cbc1c602/FHSPS-2019%2FRound1%2Fabalone.java?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "8")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/zhang0xf/ryzom-server/tree/ce696a8a02ffddc1ea2fccd902da12199dd38462/ryzomcore%2Fnel%2Ftools%2F3d%2Fpipeline_max_dump%2Fscene_2010.c?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "9")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/connorpmullins/theLastPaladin/tree/6c8c3ea6c84c9aebcdc020fbe78fb939f6b55b1e/javascript%2Flevels.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "10")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/Haoyunforever/Study/tree/5befafcf0d332b97bb37ad5e46dd93bf06b1da6b/vuln%2F5%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E6%BC%8F%E6%B4%9E%2FOpenSSL%2FOpenSSL-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E-CVE-2014-0160.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "11")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/DiameterHealth/notes-gpt2/tree/2b952872488f762e8283fca98304c33a62520e68/notes%2Fnote125%2FNote_As_Scored_125.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "12")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/nghti/Code-Remember/tree/7c3760ca03cfbbff6a4542eaf75b6af12e69f68a/03_javascript.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "13")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/THECoder12345324/Bobs-Adventures3/tree/00b079bf596fa8acbdbe66c9f21eef984ce34299/sketch.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "14")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/memset0/oi-archive-old-source/tree/3b39aba622818bd775a04cdd0d2c0e8ed5444a21/lutece%2Fgomoku%2Fdescription.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "15")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/etalab/lois-non-codifiees-et-reglements-francais/tree/9637ba59f59477ef9061fccbdc238ba1426aad22/arrete%2F2009%2Farrete-du-30-decembre-2008-devt0828761a%2Fannexes%2Fannexe-1%2Fpartie-iii%2Fchapitre-23%2Farticle-appendice.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "16")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/nikhilkalige/markdown-test-data/tree/133050e277c92ed57f97630a3102037304d9c9b5/e%2Feuwo_1988%2Findex.md?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "17")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/edeproject/svn/tree/64c8013b1543a856e1ab76e14bc1c818772f89bc/ede-1.x%2Ftags%2Fede-1.1%2Fetimedate%2Fetimedate.cpp?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "18")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/xpqz/aoc-16/tree/328ff699ca4b959c25866089ee207ba588d37b8f/day22p2.py?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "19")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/hannespetur/seqan/tree/5ae7f2a8e9c7c70bd5fc2c9c4227d60e080f6e5d/tests%2Frealign%2Ftest_realign.cpp?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "20")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/Hercha/html5gamedev/tree/85e61c436538cb1fb5753ee3972668756991b671/html5gamedev10%2Fspritoon.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "21")[43dcd9a7-70db-4a1f-b0ae-981daa162054](https://github.com/kaidenalessio/nz.js/tree/7a3cfea1190158f4f4b18960c7274f3560ead56e/examples%2F003-fruit-ninja%2Fsrc%2Fobj.js?citationMarker=43dcd9a7-70db-4a1f-b0ae-981daa162054 "22")
