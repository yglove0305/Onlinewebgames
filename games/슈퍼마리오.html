<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Canvas 마리오풍 10스테이지</title>
  <style>
    :root {
      --bg:#0b0f1a;
      --fg:#e8edf2;
      --accent:#ff6a00;
      --good:#2ecc71;
      --bad:#e74c3c;
      --ui:#1c2433aa;
      --ui-solid:#1c2433;
      --btn:#2a354a;
      --btn-press:#3b4a69;
      --shadow: 0 8px 24px rgba(0,0,0,.25);
    }
    * { box-sizing: border-box; }
    html, body {
      margin:0; padding:0; background:#0a0f18; color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      height:100%;
    }
    .wrap {
      display:flex; align-items:center; justify-content:center;
      min-height:100vh; padding:16px;
    }
    .game-shell {
      position:relative;
      width: 960px; max-width: 100%;
      aspect-ratio: 16 / 9;
      background: linear-gradient(#5ec0ff,#b7e5ff 55%, #8fd077);
      border-radius: 14px;
      overflow:hidden;
      box-shadow: var(--shadow);
      border: 2px solid #00000020;
    }
    canvas {
      width:100%; height:100%; image-rendering: pixelated; image-rendering: crisp-edges;
      display:block;
      background: transparent;
    }
    .hud {
      position:absolute; left:0; right:0; top:0;
      display:flex; gap:12px; padding:10px 12px; align-items:center; justify-content:space-between;
      font-weight:700; text-shadow: 0 2px 0 #00000066;
      pointer-events: none;
    }
    .hud .pill {
      background: var(--ui);
      border: 1px solid #ffffff20;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 14px;
      backdrop-filter: blur(8px);
    }
    .hud .group { display:flex; gap:8px; }
    .msg {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .msg-inner {
      background: #101628d0; border:1px solid #ffffff22; border-radius:12px;
      padding: 18px 20px; max-width: 80%; text-align:center; backdrop-filter: blur(8px);
    }
    .msg h1 { margin:0 0 8px; font-size:22px; }
    .msg p { margin:4px 0; opacity:.9; }
    .msg .kbd { display:inline-block; background:#00000050; border:1px solid #ffffff22; border-radius:6px; padding:2px 6px; margin:0 2px; font-weight:800; }
    .controls {
      position:absolute; left:0; right:0; bottom:0; display:flex; justify-content:space-between;
      padding: 10px; gap:10px;
    }
    .pad {
      display:flex; gap:8px;
      background: transparent;
    }
    .btn {
      width:64px; height:64px; border-radius:50%;
      background: var(--btn); border:1px solid #ffffff22; color:#fff; font-weight:900;
      display:flex; align-items:center; justify-content:center; user-select:none;
      box-shadow: var(--shadow);
      touch-action: manipulation;
    }
    .btn:active { background: var(--btn-press); }
    .dpad {
      display:grid; grid-template-columns:64px 64px 64px; grid-template-rows:64px 64px 64px; gap:6px;
      align-items:center; justify-items:center;
    }
    .dpad .spacer { width:64px; height:64px; }
    .stage-select {
      position:absolute; right:10px; top:52px; z-index:2; pointer-events:auto;
      background: var(--ui); color:#fff; border:1px solid #ffffff22; border-radius:8px; padding:6px 8px;
      font-weight:700;
    }
    @media (hover:hover) and (pointer:fine) {
      .controls { display:none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game-shell">
      <canvas id="game" width="960" height="540"></canvas>
      <div class="hud">
        <div class="group">
          <div class="pill" id="hud-stage">STAGE 1-1</div>
          <div class="pill" id="hud-lives">LIVES × 3</div>
          <div class="pill" id="hud-coins">COINS × 0</div>
        </div>
        <div class="group">
          <div class="pill" id="hud-time">TIME 300</div>
          <div class="pill" id="hud-fps">FPS —</div>
        </div>
      </div>
      <select class="stage-select" id="stageSelect" title="스테이지 선택">
        <option value="1">Stage 1</option>
        <option value="2">Stage 2</option>
        <option value="3">Stage 3</option>
        <option value="4">Stage 4</option>
        <option value="5">Stage 5</option>
        <option value="6">Stage 6</option>
        <option value="7">Stage 7</option>
        <option value="8">Stage 8</option>
        <option value="9">Stage 9</option>
        <option value="10">Stage 10</option>
      </select>
      <div class="msg" id="msg">
        <div class="msg-inner">
          <h1>마리오풍 러너 — 10 스테이지</h1>
          <p><span class="kbd">←</span><span class="kbd">→</span> 이동 · <span class="kbd">Z</span> 점프 · <span class="kbd">X</span> 대시 · <span class="kbd">P</span> 일시정지 · <span class="kbd">R</span> 재시작</p>
          <p>모바일: 좌/우 버튼 · A(점프) · B(대시)</p>
          <p>깃발에 닿으면 클리어! 스파이크는 위험, 질문블럭은 코인!</p>
          <p>아무 키나 눌러 시작</p>
        </div>
      </div>
      <div class="controls" id="touchControls" aria-hidden="true">
        <div class="dpad pad">
          <div class="spacer"></div>
          <div class="btn" data-btn="left">←</div>
          <div class="spacer"></div>
          <div class="btn" data-btn="left">←</div>
          <div class="spacer"></div>
          <div class="btn" data-btn="right">→</div>
          <div class="spacer"></div>
          <div class="spacer"></div>
          <div class="spacer"></div>
        </div>
        <div class="pad">
          <div class="btn" style="width:72px;height:72px" data-btn="jump">A</div>
          <div class="btn" style="width:72px;height:72px" data-btn="dash">B</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ========= Constants =========
  const TILE = 32;
  const GRAVITY = 2400;
  const MOVE_SPEED = 240;
  const DASH_SPEED = 360;
  const JUMP_VEL = 760;
  const MAX_FALL = 1200;
  const WORLD_HEIGHT_TILES = 17; // 17*32=544 ~ fit 540 canvas
  const SKY_COLOR = '#8fd8ff';
  const CAMERA_LERP = 0.18;

  // Tile types
  const T = {
    EMPTY: 0,
    GROUND: 1,
    BRICK: 2,
    QUESTION: 3,
    FLAG: 4,
    SPIKE: 5,
    PIPE: 6,
    CLOUD: 7, // deco
  };
  const SOLID = new Set([T.GROUND, T.BRICK, T.QUESTION, T.PIPE]);

  // ========= Utilities =========
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const sign = v => (v<0?-1:(v>0?1:0));
  const lerp = (a,b,t)=>a+(b-a)*t;
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

  // ========= Input =========
  const keys = { left:false, right:false, up:false, z:false, x:false, p:false, r:false, any:false };
  const keyMap = {
    'ArrowLeft':'left', 'ArrowRight':'right', 'ArrowUp':'up', 'Space':'z', 'KeyZ':'z', 'KeyX':'x',
    'KeyP':'p', 'KeyR':'r', 'Enter':'any'
  };
  window.addEventListener('keydown', (e)=>{
    const k = keyMap[e.code];
    if (k) { keys[k] = true; if (k!=='p') e.preventDefault(); }
    if (/Digit[0-9]/.test(e.code)) {
      const num = +e.code.replace('Digit','');
      // 1..9, 0 => 10
      if (num===0) game && game.loadStage(10); else if (num>=1 && num<=9) game && game.loadStage(num);
    }
    keys.any = true;
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{
    const k = keyMap[e.code];
    if (k) { keys[k] = false; e.preventDefault(); }
  }, {passive:false});

  // Touch controls
  const touchButtons = {};
  function bindTouchButtons() {
    document.querySelectorAll('[data-btn]').forEach(el => {
      const name = el.getAttribute('data-btn');
      const set = (v)=>{ 
        if (name==='left') { keys.left = v; if (v) keys.right = false; }
        else if (name==='right') { keys.right = v; if (v) keys.left = false; }
        else if (name==='jump') { keys.z = v; }
        else if (name==='dash') { keys.x = v; }
      };
      const start = (e)=>{ e.preventDefault(); set(true); };
      const end = (e)=>{ e.preventDefault(); set(false); };
      el.addEventListener('touchstart', start, {passive:false});
      el.addEventListener('touchend', end, {passive:false});
      el.addEventListener('touchcancel', end, {passive:false});
      el.addEventListener('mousedown', start);
      el.addEventListener('mouseup', end);
      el.addEventListener('mouseleave', end);
      touchButtons[name] = el;
    });
  }

  // ========= Camera =========
  class Camera {
    constructor(w, h) {
      this.x = 0; this.y = 0;
      this.w = w; this.h = h;
      this.targetX = 0; this.targetY = 0;
    }
    follow(px, py, worldW, worldH) {
      this.targetX = clamp(px - this.w*0.4, 0, Math.max(0, worldW - this.w));
      this.targetY = clamp(py - this.h*0.6, 0, Math.max(0, worldH - this.h));
      this.x = lerp(this.x, this.targetX, CAMERA_LERP);
      this.y = lerp(this.y, this.targetY, CAMERA_LERP);
    }
    apply(ctx) {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(-Math.floor(this.x), -Math.floor(this.y));
    }
    reset() { this.x = this.y = this.targetX = this.targetY = 0; }
  }

  // ========= TileMap =========
  class TileMap {
    constructor(w, h) {
      this.w = w; this.h = h;
      this.data = new Uint16Array(w*h).fill(0);
    }
    idx(x,y){ return y*this.w + x; }
    inBounds(x,y){ return x>=0 && y>=0 && x<this.w && y<this.h; }
    get(x,y){ if (!this.inBounds(x,y)) return T.EMPTY; return this.data[this.idx(x,y)]; }
    set(x,y,v){ if (this.inBounds(x,y)) this.data[this.idx(x,y)] = v; }
    isSolidAt(x,y) { return SOLID.has(this.get(x,y)); }
    rectSolidCollision(rx, ry, rw, rh) {
      const x0 = Math.floor(rx / TILE);
      const y0 = Math.floor(ry / TILE);
      const x1 = Math.floor((rx+rw-1) / TILE);
      const y1 = Math.floor((ry+rh-1) / TILE);
      const hits = [];
      for (let y=y0;y<=y1;y++){
        for (let x=x0;x<=x1;x++){
          const t = this.get(x,y);
          if (SOLID.has(t)) {
            hits.push({x:x*TILE, y:y*TILE, w:TILE, h:TILE, t});
          }
        }
      }
      return hits;
    }
    draw(ctx) {
      // Background decor (simple clouds drawn separately in Level)
      for (let y=0;y<this.h;y++){
        for (let x=0;x<this.w;x++){
          const t = this.get(x,y);
          const px = x*TILE, py = y*TILE;
          switch (t) {
            case T.GROUND:
              drawBlock(ctx, px, py, '#7c4b1c', '#5a3514', '#9b5e22');
              break;
            case T.BRICK:
              drawBrick(ctx, px, py);
              break;
            case T.QUESTION:
              drawQuestion(ctx, px, py);
              break;
            case T.PIPE:
              drawPipe(ctx, px, py);
              break;
            case T.SPIKE:
              drawSpike(ctx, px, py);
              break;
            case T.FLAG:
              drawFlag(ctx, px, py);
              break;
            default:
              // EMPTY / CLOUD: skip (clouds drawn as deco)
              break;
          }
        }
      }
    }
  }

  // ========= Entities =========
  class Entity {
    constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; this.vx=0; this.vy=0; this.dead=false; }
    get rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }
  }

  class Player extends Entity {
    constructor(x,y) {
      super(x,y, 24, 28);
      this.dir = 1;
      this.onGround = false;
      this.coyote = 0;
      this.jumpBuffer = 0;
      this.invuln = 0;
      this.coins = 0;
      this.lives = 3;
      this.state = 'idle'; // idle, run, jump, fall, dead, goal
    }
    spawnAt(x,y){ this.x=x; this.y=y; this.vx=0; this.vy=0; this.onGround=false; this.coyote=0; this.jumpBuffer=0; this.state='idle'; }
  }

  class Goomba extends Entity {
    constructor(x,y) {
      super(x,y, 26, 22);
      this.vx = -60;
      this.anim = 0;
    }
    update(dt, map) {
      // Gravity
      this.vy = Math.min(this.vy + GRAVITY*dt, MAX_FALL);
      // Horizontal
      this.x += this.vx * dt;
      let hits = map.rectSolidCollision(this.x, this.y, this.w, this.h);
      for (const h of hits) {
        if (this.vx > 0) this.x = h.x - this.w - 0.01;
        else if (this.vx < 0) this.x = h.x + h.w + 0.01;
        this.vx *= -1;
      }
      // Edge turn
      const aheadX = this.vx>0 ? this.x+this.w+2 : this.x-2;
      const footY = this.y + this.h + 1;
      const tileBelow = map.get(Math.floor(aheadX/TILE), Math.floor(footY/TILE));
      if (!SOLID.has(tileBelow)) this.vx *= -1;

      // Vertical
      this.y += this.vy * dt;
      hits = map.rectSolidCollision(this.x, this.y, this.w, this.h);
      for (const h of hits) {
        if (this.vy > 0) this.y = h.y - this.h - 0.01;
        else if (this.vy < 0) this.y = h.y + h.h + 0.01;
        this.vy = 0;
      }
      this.anim += dt*6;
    }
    draw(ctx) {
      drawGoomba(ctx, this.x, this.y, this.anim);
    }
  }

  class Coin extends Entity {
    constructor(x,y) {
      super(x,y, 20, 20);
      this.baseY = y;
      this.t = 0;
    }
    update(dt) {
      this.t += dt;
      this.y = this.baseY + Math.sin(this.t*3)*2;
    }
    draw(ctx) { drawCoin(ctx, this.x, this.y); }
  }

  class MovingPlatform extends Entity {
    constructor(x,y,w,h, dx,dy, len, speed) {
      super(x,y,w,h);
      this.origin = {x,y};
      this.dir = 1;
      this.dx=dx; this.dy=dy; this.len=len; this.speed=speed;
    }
    update(dt) {
      const ox = this.origin.x, oy = this.origin.y;
      const tX = ox + this.dx * this.len;
      const tY = oy + this.dy * this.len;
      const tx = this.dir>0 ? tX : ox;
      const ty = this.dir>0 ? tY : oy;
      const vx = (tx - this.x);
      const vy = (ty - this.y);
      const dist = Math.hypot(vx, vy);
      if (dist < 1) this.dir *= -1;
      else {
        const vxn = vx/dist, vyn = vy/dist;
        this.x += vxn * this.speed * dt;
        this.y += vyn * this.speed * dt;
      }
    }
    draw(ctx){ drawPlatform(ctx, this.x, this.y, this.w, this.h); }
  }

  // ========= Level =========
  class Level {
    constructor(stage) {
      this.stage = stage;
      this.map = new TileMap(1,1);
      this.spawn = {x:64, y:64};
      this.entities = [];
      this.coins = [];
      this.platforms = [];
      this.flagRect = {x:0,y:0,w:TILE,h:TILE*3};
      this.timeLimit = 300;
      this.clouds = [];
      this.width = 0; this.height = 0;
    }
  }

  // ========= Game =========
  class Game {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.camera = new Camera(canvas.width, canvas.height);
      this.player = new Player(64,64);
      this.level = null;
      this.state = 'title'; // title, playing, pause, goal, dead, clear
      this.fps = 0; this._fpsAcc=0; this._fpsCnt=0;
      this.acc = 0; this.last = performance.now();
      this.currentStage = 1;
      this.totalCoins = 0;
      this.bindUI();
      bindTouchButtons();
    }
    bindUI() {
      const sel = document.getElementById('stageSelect');
      sel.addEventListener('change', ()=> this.loadStage(+sel.value));
    }
    loadStage(n) {
      this.currentStage = clamp(n,1,10);
      this.level = generateLevel(this.currentStage);
      this.player.spawnAt(this.level.spawn.x, this.level.spawn.y);
      this.player.state = 'idle';
      this.camera.reset();
      this.state = 'playing';
      this.updateHUD();
      hideMessage();
    }
    updateHUD() {
      qs('#hud-stage').textContent = `STAGE ${this.currentStage}`;
      qs('#hud-lives').textContent = `LIVES × ${this.player.lives}`;
      qs('#hud-coins').textContent = `COINS × ${this.totalCoins}`;
      qs('#hud-time').textContent = `TIME ${Math.max(0, Math.ceil(this.level.timeLimit))}`;
      qs('#hud-fps').textContent = `FPS ${Math.round(this.fps)}`;
      document.getElementById('stageSelect').value = String(this.currentStage);
    }
    run() {
      const loop = (now) => {
        const dt = Math.min(0.05, (now - this.last)/1000);
        this.last = now;
        if (this.state!=='pause') this.tick(dt);
        this.draw();
        // FPS
        this._fpsAcc += dt; this._fpsCnt++;
        if (this._fpsAcc >= 0.5) {
          this.fps = this._fpsCnt / this._fpsAcc;
          this._fpsAcc = 0; this._fpsCnt = 0;
        }
        this.updateHUD();
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }
    tick(dt) {
      if (!this.level) return;

      // Handle pause/restart
      if (keys.p) { this.state = (this.state==='pause'?'playing':'pause'); keys.p=false; }
      if (keys.r) { this.loadStage(this.currentStage); keys.r=false; }

      if (this.state!=='playing') return;

      // Countdown
      this.level.timeLimit -= dt;
      if (this.level.timeLimit <= 0) this.killPlayer();

      // Platforms update
      for (const p of this.level.platforms) p.update(dt);

      // Player input and physics
      this.updatePlayer(dt);

      // Entities
      for (const e of this.level.entities) e.update(dt, this.level.map);

      // Collisions player with enemies / spikes / coins / flag
      this.handleInteractions();

      // Camera
      this.camera.follow(this.player.x, this.player.y, this.level.map.w*TILE, this.level.map.h*TILE);

      // Fall death
      if (this.player.y > (this.level.map.h*TILE + 200)) this.killPlayer();
    }
    updatePlayer(dt) {
      const p = this.player;
      const map = this.level.map;

      // Buffers
      p.coyote = Math.max(0, p.coyote - dt);
      p.jumpBuffer = Math.max(0, p.jumpBuffer - dt);
      if (keys.z) p.jumpBuffer = 0.15;

      // Horizontal input
      let speed = keys.x ? DASH_SPEED : MOVE_SPEED;
      let ax = 0;
      if (keys.left) { ax = -speed; p.dir = -1; }
      else if (keys.right) { ax = speed; p.dir = 1; }
      else ax = 0;

      // Smooth accel
      const targetVx = ax;
      const accel = p.onGround ? 2400 : 1400;
      if (Math.abs(targetVx - p.vx) < 10) p.vx = targetVx;
      else p.vx += clamp(targetVx - p.vx, -accel*dt, accel*dt);

      // Gravity
      p.vy = clamp(p.vy + GRAVITY*dt, -Infinity, MAX_FALL);

      // Jump (coyote + buffer)
      if ((p.coyote>0 || p.onGround) && p.jumpBuffer>0) {
        p.vy = -JUMP_VEL;
        p.onGround = false;
        p.coyote = 0;
        p.jumpBuffer = 0;
      }
      // Variable jump height
      if (!keys.z && p.vy < -220) p.vy = Math.max(p.vy, -220);

      // Horizontal move + collision
      p.x += p.vx * dt;
      let hits = map.rectSolidCollision(p.x, p.y, p.w, p.h);
      for (const h of hits) {
        if (p.vx > 0) p.x = h.x - p.w - 0.01;
        else if (p.vx < 0) p.x = h.x + h.w + 0.01;
        p.vx = 0;
      }
      // Moving platforms horizontal push
      for (const pl of this.level.platforms) {
        if (rectsOverlap(p.rect, pl.rect)) {
          if (p.vx>0) p.x = pl.x - p.w - 0.01;
          else if (p.vx<0) p.x = pl.x + pl.w + 0.01;
          p.vx = 0;
        }
      }

      // Vertical move + collision
      p.y += p.vy * dt;
      p.onGround = false;
      hits = map.rectSolidCollision(p.x, p.y, p.w, p.h);
      for (const h of hits) {
        if (p.vy > 0) { // landing
          p.y = h.y - p.h - 0.01;
          p.vy = 0; p.onGround = true; p.coyote = 0.08;
        } else if (p.vy < 0) { // head bump
          p.y = h.y + h.h + 0.01;
          p.vy = 0;
          // block interaction: question -> coin pop, brick -> coin pop (for now)
          if (h.t === T.QUESTION) this.popCoinAt(h.x, h.y);
        }
      }
      // Platforms standing
      for (const pl of this.level.platforms) {
        const prevY = p.y - p.vy * dt;
        const onTop = p.vy >= 0 && p.x + p.w > pl.x + 4 && p.x < pl.x + pl.w - 4 &&
                      prevY + p.h <= pl.y && p.y + p.h >= pl.y;
        if (onTop) {
          p.y = pl.y - p.h - 0.01;
          p.vy = 0; p.onGround = true; p.coyote = 0.08;
          // ride velocity
          p.x += (pl.x - (pl._lastX ?? pl.x));
          p.y += (pl.y - (pl._lastY ?? pl.y));
        }
        pl._lastX = pl.x; pl._lastY = pl.y;
      }

      // State
      if (!p.onGround && p.vy < 0) p.state = 'jump';
      else if (!p.onGround && p.vy >= 0) p.state = 'fall';
      else if (Math.abs(p.vx) > 5) p.state = 'run';
      else p.state = 'idle';

      if (p.invuln > 0) p.invuln -= dt;
    }
    popCoinAt(x,y) {
      // Convert question block to brick after one coin
      const gx = Math.floor(x / TILE), gy = Math.floor(y / TILE);
      this.level.map.set(gx, gy, T.BRICK);
      // Spawn coin above
      this.level.coins.push(new Coin(x + TILE/2 - 10, y - TILE/2));
    }
    handleInteractions() {
      const p = this.player;
      const map = this.level.map;

      // Coins
      for (const c of this.level.coins) c.update(1/60);
      for (const c of this.level.coins) {
        if (!c.dead && rectsOverlap(p.rect, c.rect)) {
          c.dead = true; this.totalCoins++; p.coins++;
        }
      }
      this.level.coins = this.level.coins.filter(c=>!c.dead);

      // Enemies
      for (const e of this.level.entities) {
        if (e.dead) continue;
        if (rectsOverlap(p.rect, e.rect)) {
          // Stomp: coming from above with vy > 120
          const fromAbove = (p.vy > 120) && (p.y + p.h - e.y) < 14;
          if (fromAbove) {
            e.dead = true;
            p.vy = -420; p.onGround = false;
          } else {
            this.hurtPlayer();
            break;
          }
        }
      }

      // Spikes
      const spikes = this.sampleTilesUnder(p.rect, t=>t===T.SPIKE);
      if (spikes.length>0) { this.killPlayer(); return; }

      // Flag (goal)
      const goalTiles = this.sampleTilesUnder(p.rect, t=>t===T.FLAG);
      if (goalTiles.length>0) { this.nextStage(); }
    }
    sampleTilesUnder(rect, pred) {
      const x0 = Math.floor(rect.x / TILE);
      const y0 = Math.floor(rect.y / TILE);
      const x1 = Math.floor((rect.x+rect.w-1)/TILE);
      const y1 = Math.floor((rect.y+rect.h-1)/TILE);
      const out = [];
      for (let y=y0;y<=y1;y++){
        for (let x=x0;x<=x1;x++){
          const t = this.level.map.get(x,y);
          if (pred(t)) out.push({x,y,t});
        }
      }
      return out;
    }
    hurtPlayer() {
      const p = this.player;
      if (p.invuln > 0) return;
      p.invuln = 1.2;
      p.vx = -p.dir * 160;
      p.vy = -420;
      p.onGround = false;
      p.state = 'hurt';
      p.lives--;
      if (p.lives <= 0) this.gameOver();
    }
    killPlayer() {
      const p = this.player;
      p.state='dead';
      p.lives--;
      if (p.lives <= 0) this.gameOver();
      else this.respawn();
    }
    respawn() {
      const p = this.player;
      p.invuln = 0;
      p.spawnAt(this.level.spawn.x, this.level.spawn.y);
    }
    gameOver() {
      this.state='title';
      this.totalCoins=0;
      this.player.lives=3;
      showMessage('게임 오버', '아무 키나 눌러 다시 시작', true);
    }
    nextStage() {
      if (this.currentStage >= 10) {
        this.state='title';
        showMessage('축하합니다! 올클리어!', '아무 키나 눌러 1스테이지부터 다시', true);
        this.currentStage = 1;
        this.totalCoins = 0;
      } else {
        this.currentStage++;
      }
      this.loadStage(this.currentStage);
    }
    draw() {
      const ctx = this.ctx;
      const W = this.canvas.width, H = this.canvas.height;
      // Clear sky gradient
      ctx.setTransform(1,0,0,1,0,0);
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, '#7fcfff');
      g.addColorStop(0.55, '#bfe8ff');
      g.addColorStop(0.56, '#a1d37f');
      g.addColorStop(1, '#78b55f');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      if (!this.level) return;

      // Clouds (deco parallax)
      drawClouds(ctx, this.level.clouds, this.camera);

      // World
      this.camera.apply(ctx);
      this.level.map.draw(ctx);

      // Platforms
      for (const pl of this.level.platforms) pl.draw(ctx);

      // Coins
      for (const c of this.level.coins) c.draw(ctx);

      // Enemies
      for (const e of this.level.entities) e.draw(ctx);

      // Player
      drawPlayer(ctx, this.player);

      // Ground line at bottom (deco)
      ctx.strokeStyle = '#00000020';
      ctx.beginPath();
      ctx.moveTo(this.camera.x, this.level.map.h*TILE + 0.5);
      ctx.lineTo(this.camera.x + W, this.level.map.h*TILE + 0.5);
      ctx.stroke();
    }
  }

  // ========= Level Generator (10 stages) =========
  function generateLevel(stage) {
    const lvl = new Level(stage);

    const widthTiles = 220 + stage*15;
    const heightTiles = WORLD_HEIGHT_TILES;
    lvl.map = new TileMap(widthTiles, heightTiles);
    lvl.width = widthTiles*TILE; lvl.height = heightTiles*TILE;

    // Build base ground with occasional gaps increasing by stage
    const groundY = heightTiles - 2;
    for (let x=0;x<widthTiles;x++){
      const isGap = (x>8) && (x%Math.max(8, 18 - stage)===0);
      const gapWidth = (stage>=6 && x%37===0) ? 2 : 1;
      for (let y=0;y<heightTiles;y++){
        if (y > groundY) lvl.map.set(x,y, T.GROUND);
        else if (y===groundY && !(isGap && (x%2<gapWidth))) lvl.map.set(x,y, T.GROUND);
      }
    }

    // Pipes, spikes, bricks, questions, platforms, enemies pattern by stage
    placeClouds(lvl, widthTiles, heightTiles);
    placePipes(lvl, stage);
    placeBricksAndQuestions(lvl, stage);
    placeSpikes(lvl, stage);
    placePlatforms(lvl, stage);
    placeCoinsLine(lvl, stage);
    placeEnemies(lvl, stage);

    // Spawn & Flag
    lvl.spawn = {x: TILE*3, y: (groundY-3)*TILE};
    const flagX = widthTiles - 8;
    for (let y=groundY-5;y<=groundY;y++){
      lvl.map.set(flagX, y, y===groundY-5 ? T.FLAG : T.GROUND);
    }
    lvl.flagRect = {x: flagX*TILE, y:(groundY-6)*TILE, w:TILE, h:TILE*6};

    // Time limit scaling
    lvl.timeLimit = clamp(320 - stage*12, 120, 320);

    // Bonus coins near start
    for (let i=0;i<4;i++) lvl.coins.push(new Coin(lvl.spawn.x + i*26, lvl.spawn.y - 64 - (i%2)*8));

    return lvl;
  }

  function placeClouds(lvl, wTiles, hTiles) {
    const clouds = [];
    const count = Math.floor(wTiles / 10);
    for (let i=0;i<count;i++){
      clouds.push({x: Math.random()*wTiles*TILE, y: 48 + Math.random()*120, s: 0.3 + Math.random()*0.6});
    }
    lvl.clouds = clouds;
  }

  function placePipes(lvl, stage) {
    const map = lvl.map;
    const groundY = map.h - 2;
    const interval = Math.max(18 - stage, 9);
    for (let x=16; x<map.w-20; x += interval) {
      const h = 2 + (x % 4);
      for (let y=groundY - h; y<groundY; y++){
        map.set(x, y, T.PIPE);
        map.set(x+1, y, T.PIPE);
      }
    }
  }

  function placeBricksAndQuestions(lvl, stage) {
    const map = lvl.map;
    const gy = map.h - 2;
    for (let x=8;x<map.w-8;x+=6) {
      const y = gy - (3 + (x%3));
      if (Math.random() < 0.5) map.set(x, y, T.BRICK);
      if (Math.random() < 0.35) map.set(x+1, y, T.QUESTION);
      if (Math.random() < 0.5 && stage>=5) map.set(x+2, y, T.BRICK);
    }
  }

  function placeSpikes(lvl, stage) {
    if (stage < 3) return;
    const map = lvl.map;
    const gy = map.h - 1;
    for (let x=24; x<map.w-24; x += Math.max(12 - Math.floor(stage/2), 6)) {
      map.set(x, gy, T.SPIKE);
      if (stage>=7) map.set(x+1, gy, T.SPIKE);
    }
  }

  function placePlatforms(lvl, stage) {
    const map = lvl.map;
    const gy = map.h - 2;
    const count = 3 + Math.floor(stage/2);
    for (let i=0;i<count;i++){
      const x = (20 + i*Math.max(20 - stage, 10)) * TILE;
      const y = (gy - (4 + (i%3))) * TILE;
      const w = 80, h = 12;
      const dir = (i%2===0) ? {dx:1,dy:0} : {dx:0,dy:1};
      const len = 80 + (stage*12);
      const speed = 40 + i*6;
      lvl.platforms.push(new MovingPlatform(x, y, w, h, dir.dx, dir.dy, len, speed));
    }
  }

  function placeCoinsLine(lvl, stage) {
    const map = lvl.map;
    const gy = map.h - 2;
    for (let x=12; x<map.w-12; x+= 10) {
      const y = gy - 5 - (x%3);
      lvl.coins.push(new Coin(x*TILE + TILE/2 - 10, y*TILE + 8));
    }
  }

  function placeEnemies(lvl, stage) {
    const map = lvl.map;
    const gy = map.h - 2;
    const count = 8 + stage*3;
    for (let i=0;i<count;i++){
      const tx = 10 + Math.floor(Math.random() * (map.w - 20));
      const ty = gy - 1;
      const e = new Goomba(tx*TILE, ty*TILE);
      e.vx = (Math.random()<0.5?-1:1) * (50 + Math.random()*40 + stage*4);
      lvl.entities.push(e);
    }
  }

  // ========= Drawing helpers =========
  function drawBlock(ctx, x,y, base, edge, light) {
    ctx.fillStyle = base; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle = edge; ctx.fillRect(x, y+TILE-6, TILE, 6);
    ctx.fillStyle = light; ctx.fillRect(x+3, y+3, TILE-6, 4);
  }
  function drawBrick(ctx, x,y) {
    drawBlock(ctx, x,y, '#9e4d38','#6e2f23','#c86a54');
    ctx.strokeStyle = '#6e2f23';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y+16); ctx.lineTo(x+TILE, y+16);
    ctx.moveTo(x+8, y); ctx.lineTo(x+8, y+16);
    ctx.moveTo(x+24, y+16); ctx.lineTo(x+24, y+TILE);
    ctx.stroke();
  }
  function drawQuestion(ctx, x,y) {
    drawBlock(ctx, x,y, '#f7b733','#c97d10','#ffd46a');
    ctx.fillStyle = '#5a2a00';
    ctx.font = 'bold 18px monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('?', x+TILE/2, y+TILE/2+1);
  }
  function drawPipe(ctx, x,y) {
    // 2 tiles wide pipe
    ctx.fillStyle = '#2dbf5a';
    ctx.fillRect(x, y, TILE*2, TILE);
    ctx.fillRect(x, y+TILE, TILE*2, TILE);
    ctx.strokeStyle = '#189442';
    ctx.lineWidth = 3;
    ctx.strokeRect(x+2, y+2, TILE*2-4, TILE-4);
    ctx.strokeRect(x+6, y+TILE+2, TILE*2-12, TILE-4);
  }
  function drawSpike(ctx, x,y) {
    ctx.fillStyle = '#e7e7e7';
    ctx.beginPath();
    ctx.moveTo(x, y+TILE);
    ctx.lineTo(x+TILE/2, y);
    ctx.lineTo(x+TILE, y+TILE);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#afafaf'; ctx.stroke();
  }
  function drawFlag(ctx, x,y) {
    // pole
    ctx.fillStyle = '#ffffff'; ctx.fillRect(x+TILE/2-2, y-4*TILE, 4, 5*TILE);
    // flag
    ctx.fillStyle = '#ff3b3b';
    ctx.beginPath();
    ctx.moveTo(x+TILE/2, y-4*TILE+8);
    ctx.lineTo(x+TILE/2 + 24, y-4*TILE + 16);
    ctx.lineTo(x+TILE/2, y-4*TILE + 24);
    ctx.closePath(); ctx.fill();
  }
  function drawCoin(ctx, x,y) {
    ctx.fillStyle = '#ffd34d';
    ctx.beginPath(); ctx.ellipse(x+10, y+10, 10, 10, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#c89c28'; ctx.stroke();
    ctx.fillStyle = '#fff6';
    ctx.fillRect(x+4, y+4, 4, 12);
  }
  function drawPlatform(ctx, x,y,w,h) {
    ctx.fillStyle = '#445d8d'; ctx.fillRect(x,y,w,h);
    ctx.fillStyle = '#ffffff22'; ctx.fillRect(x+2,y+2,w-4,3);
  }
  function drawGoomba(ctx, x,y, t) {
    const bob = Math.sin(t)*2;
    ctx.save();
    ctx.translate(x,y+bob);
    ctx.fillStyle = '#8b4f21';
    ctx.fillRect(0, 6, 26, 16);
    ctx.fillStyle = '#6c3c18';
    ctx.fillRect(2, 18, 10, 6);
    ctx.fillRect(14, 18, 10, 6);
    // eyes
    ctx.fillStyle = '#fff';
    ctx.fillRect(6, 8, 5, 6);
    ctx.fillRect(15, 8, 5, 6);
    ctx.fillStyle = '#000';
    ctx.fillRect(8, 11, 2, 3);
    ctx.fillRect(17, 11, 2, 3);
    ctx.restore();
  }
  function drawPlayer(ctx, p) {
    // flicker when invuln
    if (p.invuln>0 && Math.floor(p.invuln*20)%2===0) return;
    ctx.save();
    ctx.translate(p.x, p.y);
    // body
    ctx.fillStyle = '#ff4d4d'; // cap/shirt color
    // head
    ctx.fillRect(6, 0, 12, 12);
    // body
    ctx.fillStyle = '#2a6bff';
    ctx.fillRect(4, 12, 16, 12);
    // legs
    ctx.fillStyle = '#2a6bff';
    ctx.fillRect(4, 24, 6, 4);
    ctx.fillRect(14, 24, 6, 4);
    // face/hat detail
    ctx.fillStyle = '#ffb38a';
    ctx.fillRect(8, 6, 8, 6);
    // direction flip
    if (p.dir<0) {
      ctx.translate(p.w,0);
      ctx.scale(-1,1);
    }
    ctx.restore();
  }
  function drawClouds(ctx, clouds, camera) {
    ctx.save();
    const parallax = 0.5;
    ctx.setTransform(1,0,0,1,0,0);
    for (const c of clouds) {
      const x = (c.x - camera.x*parallax) % (camera.w*2);
      const y = c.y;
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(x, y, 28*c.s, 16*c.s, 0, 0, Math.PI*2);
      ctx.ellipse(x+18, y+4, 24*c.s, 14*c.s, 0, 0, Math.PI*2);
      ctx.ellipse(x-18, y+6, 20*c.s, 12*c.s, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // ========= DOM helpers =========
  function qs(sel){ return document.querySelector(sel); }
  const msgEl = document.getElementById('msg');
  function showMessage(title, subtitle, hold=false) {
    msgEl.querySelector('h1').textContent = title;
    msgEl.querySelectorAll('p')[msgEl.querySelectorAll('p').length-1].textContent = hold ? '아무 키나 눌러 진행' : '아무 키나 눌러 시작';
    msgEl.style.display = 'flex';
  }
  function hideMessage() { msgEl.style.display = 'none'; }

  // ========= Boot =========
  const canvas = document.getElementById('game');
  const game = new Game(canvas);
  window.game = game; // for debugging in console

  // Start on any key/touch from title
  function startFromTitle() {
    if (game.state === 'title') {
      game.loadStage(1);
    }
  }
  document.addEventListener('keydown', startFromTitle);
  document.addEventListener('mousedown', startFromTitle);
  document.addEventListener('touchstart', (e)=>{ startFromTitle(); e.preventDefault(); }, {passive:false});

  // Resize handling (keep internal resolution)
  function onResize() {
    // Canvas fixed internal size; CSS scales it. Nothing needed.
  }
  window.addEventListener('resize', onResize);

  game.run();
})();
</script>
</body>
  </html>
